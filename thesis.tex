\documentclass[a4paper, oneside]{discothesis}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{cprotect}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{dirtree}
\usepackage{mathtools}
\usepackage{comment}
\usepackage[labelfont=bf,font=small,skip=5pt]{caption}
\usepackage[outdir=./figures/]{epstopdf}
\usepackage{titlesec}


\setcounter{secnumdepth}{3}
\usepackage{hyperref}

% suppress hbadness in .bbl warning
\usepackage{etoolbox}
\apptocmd{\sloppy}{\hbadness 10000\relax}{}{}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}


\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}
\lstset{style=mystyle}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT METADATA

\thesistype{Master's thesis} % Master's thesis, Bachelor's thesis, Semester thesis, Group Project
\title{On differentiable simulations of haemodynamic systems}

\author{Diego Renner}
\email{drenner@student.ethz.ch}

\institute{Dep. of Mathematics \\[2pt]
ETH Zürich}

% Optionally, you can put in your own logo here

\supervisors{Prof. Dr. Siddhartha Mishra}
\cosupervisors{Dr. Georgios Kissas, Dr. Benjamin Moseley}

% Optionally, keywords and categories of the work can be shown (on the Abstract page)
%\keywords{Keywords go here.}
%\categories{ACM categories go here.}

\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\frontmatter % do not remove this line
\maketitle
\cleardoublepage

\begin{acknowledgements}
	Firstly I would like to thank Prof. Dr. Mishra from the Seminar of Applied Mathematics at ETH Zurich for giving me the opportunity to work on this project and guiding my process.	
	I'm very grateful to have been able to work on this interesting topic and get the input of someone who is so experienced in the field of fluid dynamics and machine learning.

	Furthermore I would like to thank Dr. Kissas and Dr. Moseley from the ETH AI Center for having answered so many of my questions throughout this thesis.
	Be it about the intricacies of JAX, the details of modelling haemodynamics, or the scientific writing process, I could always count on them for a solid answer despite their own busy schedules.

	Finally I would like to thank my family for supporting me throughout my studies and making it possible for me to pursue my interest in the sciences.

\end{acknowledgements}


\begin{abstract}
	Personalised medicine aims to improve clinical results by customizing treatments for individual patients.
	This customization is achieved by measuring indicative quantities (biomarkers) by which a patient can be assessed more closely and categorized into sub-populations.
	In some cases (e.g. hypertension), the biomarker most closely related to the disease (e.g. local vascular pressure) is difficult and maybe even risky to measure (e.g. hypertensive pregnancy disorder).
	Therefore computational methods are applied to infer such hard to access or unavailable data by solving an inverse problem.
	The current methods by which this is done are either inefficient, due to relying on slow optimization methods, or hard to interpret, due to using "black box" deep-learning algorithms.
	Since cardiovascular diseases are the leading cause of death globally they are a prime target to which to apply the personalised medicine approach.
	In this field however, the caveat in personalised medicine of difficult to access biomarkers applies as well.
	Therefore this thesis aims to produce a differentiable 1D-haemodynamics solver based on well understood methods such as the 1D-Navier-Stokes equations and their treatment via the MUSCL numerical scheme.
	The underlying motivation thereof being the bridging of the gap between inefficient and hard to interpret models.
	By providing a faster method to perform parameter inference and sensitivity analysis through differentiability while keeping interpretability of the well understood mathematical models and numerical methods, the best of both worlds is combined.
	The results of our solver were validated using data from previous work in the 1D-haemodynamics field and we demonstrated that parameter inference can be performed using our model.

\end{abstract}

\tableofcontents

\mainmatter % do not remove this line

\chapter{Introduction}
By taking into account the characteristics of an individual patient and customizing their treatment according to which characteristics-dependent sub-population they fall into, personalised medicine aims to improve upon results a more generalized approach would achieve \cite{ashley2016towards,national2011toward,giardino2017role}.
To succeed in the personalisation of a treatment, a disease specific number of quantities (biomarkers) need to be determined \cite{burke1998integrating}.
These biomarkers can have a varying degree of correlation with a disease's existence, progression, and outcome.
For instance local vascular pressure is highly correlated with hypertension.
While there are methods to estimate this quantity from ultrasound or Magnetic Resonance Imaging \cite{markl20124d}, these methods tend not to be accurate enough for standard clinical practice \cite{everett2012beyond}.
On the other hand more invasive techniques might not offer the proper risk to reward ratio.
For example, to diagnose hypertensive pregnancy disorder it would be very risky to perform the measurement of the absolute vascular pressure in vivo on a pregnant subject \cite{kett2002adverse}.
Therefore, in order to determine the biomarkers that are hard to capture in a clinical setting, computational methods are often applied.

Such computational models aim to simulate a patients individual physiology in order to reveal aforementioned "hidden" biomarkers.
This is especially useful when the computed biomarkers can be connected via first principals to the outcome of a disease.
Here we mention again local vascular pressure and hypertension as a prime example.
However simulating such quantities accurately depends heavily on a high number of personalised parameters, leading to a similar problem as described initially: needing to access difficult to measure or unobtainable data for a specific patient.
An attempt to avoid the problem of having to know these values for each individual is using population averaged means.
This however defeats the purpose of personalised medicine.
What has therefore become the method of choice to address the issue of personalised medicine using computational models is to build simulators that output the values of some desired biomarkers and to then try and solve the inverse problem of fitting the parameters of the simulator to a specific patient.

There are two main ways of achieving the goal of calibrating a simulation for an individual:
\begin{enumerate}
	\item A "classical" approach where the inverse problem is solved using Markov-Chain-Monte-Carlo samplers \cite{melis2017gaussian}, or Kalman filters \cite{manganotti2022modeling}.
	\item A deep-learning approach where the calibration is avoided all together in favour of learning the model from data \cite{kissas2020machine,arzani2022machine}.
\end{enumerate}
The reason deep-learning techniques were attempted is due to the fact that the "classical" approaches are very inefficient.
This is in part because derivatives are often hard to determine for the attempted simulations so the algorithms of choice for solving the inverse problem are gradient-free. 
Moreover due to the models being very sensitive to their parameters and there being ambiguous solutions \cite{nolte2022inverse,quick2001infinite} these gradient-free algorithms have to be run at very small step sizes. \cite{taylor2009patient,tuccio2022parameter,marsden2014optimization,mineroff2019optimization,bozkurt2022patient}
The ability to easily take gradients of one of these models with respect to it's parameters would greatly improve the process of personalising it without losing the interpretability, as would be the case when using a deep-learning algorithm.
Personalised medicine could specifically be aided by using gradients to more efficiently infer parameters or perform sensitivity analysis.

%Due to the complexity of the cardiovascular system and the significance of cardiovascular disease globally the mathematical and numerical modelling of haemodynamics has gained a lot of traction over recent years.
%Two of the main factors for this complexity are the multi-scale and multi-physics nature of the cardiovascular system that arises from vessels of strongly varying sizes and not much data being available for certain parts of these models to go off of \cite{quarteroni2016geometric}.
The cardiovascular system and cardiovascular disease are prime targets for the approaches of personalised medicine. 
The significance of cardiovascular disease and it's research stems from it being the most prevalent cause of death.
Worldwide it lead to 17.3 million deaths per year as of 2015.
This number is projected to increase by the year 2030 to more than 23.6 million. \cite{update2015heart}
In Europe, cardiovascular disease was responsible for close to one third (32.7\%) of all deaths in the year 2020 \cite{Coelho2020}.
Therefore, cardiovascular systems have been well studied from analytical solutions of simplified models to approximations of complex systems.
In order to tackle this complexity of the meaningful task of modelling cardiovascular systems, numerical modelling has become prevalent \cite{formaggia2009multiscale,quarteroni2016geometric,black2020p14,el2018investigating,qureshi2014numerical,reichold2009vascular}.
The issue of needing access to hard to obtain biomarkers and the pitfalls of the existing simulations providing such biomarkers hold as well in the case of cardiovascular disease.

Therefore, the goal of this work is to provide a fast, differentiable cardiovascular simulation.
This is a step towards enabling efficient and interpretable model calibration to be applied in personalised medicine.
In order to be differentiable, the haemodynamics solver written in the course of this thesis was written using the JAX library \cite{jax123}.
On top of differentiability, JAX also offers device agnostic execution.
That is, JAX optimizes the written code to take advantage of parallelization and other advantages of modern hardware regardless of being executed on a CPU, GPU or TPU.
The optimization for GPU execution is especially useful since it allows for data parallelization, i.e. batch executions of the code on a single device.
This means multiple models for different patients could be optimized simultaneously on a single GPU.
Next to the advantages brought about by the implementation in JAX, the implementation of the code in Python makes the solver accessible for future work.
We also provide the written code as is in an open-source manner hoping to aid progress in the field overall. 
In order to write this code there were many modelling assumptions to be made before attempting to implement the solver.

For this thesis we chose a coupled 0D-1D model where the 0D-component is used to compute boundary conditions for certain outlets of the 1D-cardiovascular network.
While failing to capture complex flow patterns and wall shear stress as opposed to a 3D-model, the 1D-model can still simulate pulse wave transmission and systemic wave reflection effects.
Clearly 1D-models also offer a big advantage in execution time as opposed to 3D-models. \cite{shi2011review,pfaller2020using,arzani2022machine} 
Finally, before starting out by giving a description of the cardiovascular system as a baseline for our understanding when describing the modelling approach, we provide an outlook on the content of this thesis in the following paragraph.

In \autoref{chap:cvs} we will provide a description of the cardiovascular system which will serve as a foundation for describing the cardiovascular simulation throughout this work.
Thereafter, in \autoref{chap:1dm} we will describe the underlying 1D-model that we used to simulate blood flow in a single vessel.
In \autoref{chap:nm} we explain how to solve this model numerically and how to couple multiple such models in order to simulate a cardiovascular network.
Then, in \autoref{chap:impl}  we will describe key factors of how we implemented the numerical algorithms that solve our 1D-model.
In the second to last chapter, \autoref{chap:resl}, we validate this code and present the results produced by it, including a parameter inference performed on a toy problem.
Lastly, we conclude this work by summarizing our results and giving an outlook on future work in \autoref{chap:conc}.



% 1) Introduction
% why cardiovascular simulation important
% description of the current ways to simulate
% description of the problems/limitations of these methods
% how our approach works
% and _why_ it solves issues of previous methods
% list specific contributions:
% a 1D solver which is
% - written for GPU on JAX
% - highly scalable (multi-GPU / device agnostic)
% - differentiable
% - open source
% - easy to understand (written in python)
% future work / impact it will have in the future
% path towards complex, real-world simulation
% digital twin, data assimilation, etc ..

% 2) Cardiovascular system
% why cardiovascular simulation important

% 3) 1D Model
% mathematical model

% 4) Existing numerical models
% description of the current ways to simulate
% description of the problems/limitations of these methods

% 5) Our implementation
% how our approach works
% and _why_ it solves issues of previous methods
% nice overview diagram showing workflow

% 6) Results & benchmarks
% timing tests / accuracy compared to Julia model
% GPU vs CPU time
% scaling tests:
% computational time vs number of vessels
% vmap multiple simulations
% time to compute gradients / linear approximation of function

% 7) Discussion
% future work / impact it will have in the future
% multi-GPU
% sensitivity tests
% open-sourcing
% maybe including proof-of-principle inverse test

% 8) Conclusions 
% (repeat contribution / impact)

\chapter{Cardiovascular System} \label{chap:cvs}
This section serves as an overview of the cardiovascular system with a focus on the arteries of the systemic circulation, since this is where our simulation efforts will be focused. 
Section \ref{sec:mbb} will describe the main building blocks of the cardiovascular system and their relation to one another, section \ref{sec:aw} will give the characteristics of the arterial walls, and section \ref{sec:b} the characteristics of blood.
We start off with a macro view of the cardiovascular system.
\section{Main Building Blocks} \label{sec:mbb}
The cardiovascular system contains two major circulatory systems.
These are the systemic and the pulmonary circulation. 
Both are fed with blood pumped from the heart.
Through the systemic circulation, organs are supplied with oxygen-rich blood which is then transported back to the heart, where it enters the pulmonary circulation.
Through the pulmonary circulation, the oxygen-poor blood is sent to the lungs, where it is replenished with oxygen and then returned to the heart to re-enter the systemic circulation.
Vessels carrying the blood away from the heart are referred to as arteries and the ones carrying the blood to the heart are referred to as veins.
In both the systemic and the pulmonary circulation, the oxygen exchange (from blood to organs or from lungs to blood respectively) takes place within so-called capillary vessels.
Capillaries are very small vessels that connect arteries to veins. \cite{köppl2023dimension}
From here on out our main focus will be on on the arteries of the systemic circulation since our simulation approach will assume the heart to be represented by pre-computed data and the effect of the capillary bed and the veins will be accounted for by a lumped parameter model (0D-model, \autoref{sssec:outl}).
We also define the notation for $T$ as the duration of one cardiac cycle (the time between the beginnings of two subsequent heartbeats).
In the next two subsections we will describe the main characteristics of the arterial walls and the blood flowing within.

\section{Arterial Wall} \label{sec:aw}
An arterial wall consists of three layers or tunicae: an inner, middle, and outer layer also referred to as intima, media, and adventita respectively.
The tunica intima lines the inside of the artery. It is made up of a single layer of endothelial cells encased in a thin layer of elastin and collagen fibres (connective tissue). 
On the outside of the artery, the tunica adventita is made up of connective tissue as well which attaches the artery to surrounding connective tissue.
In-between these two layers lies the thickest layer, the tunica media, which consists of elastic fibres and muscle cells. 

The tunica media is responsible for the elasticity of the artery.
Arteries close to the heart have a tunica media that is mainly made up of elastic fibres and are referred to as elastic arteries while the tunica media of arteries farther away from the heart and of smaller arteries consist predominantly of muscle cells and are called muscular arteries.
The elastic arteries also have a higher compliance than the muscular arteries.
This means that elastic arteries are able to distend and increase their volume as a response to pressure applied to the inside of the arterial wall.
Hence elastic arteries deform more under pressure than muscular arteries that are stiffer and don't distend as much when blood is pumped into them by the heart.
At the same time, usually the elastic arteries are larger than the muscular arteries and the size of arteries generally decreases as the distance to the heart increases.

The compliance of the larger elastic arteries is responsible for transforming the pulsatile flow at the heart into a constant flow at the capillaries.
The pulse-like pressure change coming from the heart leads to the elastic arteries close to the heart expanding.
Until the next pulse arrives these vessels will contract slowly, pushing the blood at a constant rate into the arteries farther away from the heart and finally into the capillaries.
This mechanism is called the Windkessel effect.
It is named after the inner workings of water pumps used by early fire brigades.
In these devices, water would be pumped by hand from the reservoir causing pressure pulses.
This pushes the water into an air chamber.
Here, the air gets compressed, which is analogous to the deforming of the artery.
The natural decompressing of the air would then push the water out through the hose in a steady manner, just like the contracting of the artery would push the blood on to other vessels.
The Windkessel effect is often applied in vascular simulations to set outlet boundary values. \cite{köppl2023dimension}
We will describe how boundary values are set using the Windkessel more closely in \autoref{sssec:outl}.

For further reference in the following chapters we will introduce some notation.
We call the radius of an artery in it's non-deformed state the lumen radius $r_0$ and refer to the reference vessel wall thickness by $h_0$ from here on out.
Furthermore we denote the reference cross-section by $A_0 = \pi r_0^2$.
In the next section we will discuss some simulation relevant properties of blood.

\section{Blood} \label{sec:b}
Blood consists of red blood cells (Erythrocytes), white blood cells (Leukocytes), and platelets (Thrombocytes).
The Erythrocytes make up about 97\% of the cellular volume.
They are flexible, can bind to one another, and their micro-structure determines the blood mechanical properties.
The volume occupied by red blood cells in respect to the total blood volume is called the haematocrit value.
At different age, altitude, health, and bodily activity the haematocrit value varies. We want to relate the haematocrit value with the blood dynamic viscosity and the so-called shear rate in order to determine if blood can be considered a Newtonian fluid. In order to do so we first introduce the shear stress
\begin{equation}
	\tau = \frac{F}{A}
\end{equation}
where $F$ is the force applied coplanar to the cross-section and $A$ is the surface of the cross-section.
The cross-section affected by the shear stress is deformed at a certain angle. 
This angle can be assigned an angular velocity and is referred to as the shear rate.
We denote the shear rate by $D$. \cite{köppl2023dimension}
The blood dynamic viscosity $\mu$ decreases hyperbolically with the shear rate $D$.
At about $D > 100s^{-1}$, the viscosity stays constant for common haematocrit values.
In larger arteries the average shear rate close to the walls is above the $100s^{-1}$ threshold. \cite{MCDbook}
Therefore, the blood's viscosity is often considered constant and it can roughly be viewed as a Newtonian fluid for the sake of simplicity \cite{fung2013biomechanics,guyton2006textbook,MCDbook,pedley_1980,zamir2000physics,zamir2006physics}. 
Another important property of a fluid when attempting to model it is it's compressibility. 

The blood density $\rho$ is considered constant within the range of $1050 \pm 10 \text{ kg}\cdot\text{m}^{-3}$, i.e. blood can be considered an incompressible fluid \cite{PMID:2658951,kenner1977continuous,helmig1997multiphase}.
The assumption of blood being an incompressible Newtonian fluid will be important when constructing the underlying model for our cardiovascular solver in \autoref{sec:sv}. In the next chapter we will start building this model with a discussion on the choice of dimensionality when modelling.

\chapter{Modelling approach} \label{chap:1dm}
In this chapter we will discuss the different approaches that can be taken when creating a model for a vascular simulation and which one we are going to be using in \autoref{sec:ma}.
After that we will give a mathematical description of the model we chose in \autoref{sec:sv}.

\section{Different Modelling Approaches} \label{sec:ma}
In this thesis, we focus on simulating macro-circulation in arteries, i.e. cardiovascular networks consisting of the largest arteries of the human circulation.
The length and diameters of these vessels are on the scale of meters.
According to with which accuracy the system is supposed to be represented, models of different dimensionality can be chosen.
3D-models for instance can represent such quantities as turbulence or wall shear stresses.
1D-models cannot represent these 3D-quantities but can still compute pressure and flow along an artery at reasonable accuracy while requiring significantly less computation than a 3D-model.
Finally, 0D-models such as the Windkessel model can represent the approximate behaviour of ensembles of vessels and are often used to simulate the outlets of a network modelled in higher dimensions, where it would be too costly to simulate every vessel individually at the increased accuracy.

On one end of this spectrum (3D-models), there is high accuracy but also high computational effort.
On the other end (0D-models), only very simplified structures can be represented but at a considerably lower cost.
In practice it is therefore very common to couple such models, choosing the more demanding models for locations in the vascular network that require more attention to be simulated accurately or that simply are of special interest.
This leads to 3D-1D-0D-models where the junctions in the network are represented by 3D-models, 1D-models are used to simulate the flow within vessels, and the 0D-models are used to compute the data at the outlets of the network.
In the setting of this thesis, the outlets are omitted vessels that are not included in the model due to not being of interest for these simulations and wanting to reduce computational effort.

Another important distinction between types of models are open and closed models.
In closed models the Windkessel models at the outlets are connected back to the inlet of the system.
In open models the inlet is fed by some sort of input data and the Windkessel models only serve to compute boundary conditions at the outlets.\cite{köppl2023dimension}
The model presented here will be an open model for the sake of simplicity.
A further simplification was to only consider a 1D-0D-model since the main goal of this work was to produce a fast and differentiable solver.
Incorporating 3D-models in this work would have added additional complexity without providing benefits in terms of speed and reasoning w.r.t. differentiability. 

\section{1D-Model} \label{sec:sv}
Within a vessel, we consider the conservation of mass and momentum in cylindrical coordinates that hold for any fluid, to be satisfied.
In cylindrical coordinates these conservation laws read
\begin{equation}
	\frac{\partial \rho (z,r,\phi; t)}{\partial t} + \nabla \cdot \rho (z,r,\phi; t)\mathbf{u}(z,r,\phi; t) = 0, \label{eq:cont}
\end{equation}
\begin{multline}
	\frac{\partial \mathbf{u}(z,r,\phi; t)}{\partial t} + \left( \mathbf{u}(z,r,\phi; t) \cdot \nabla \right) \mathbf{u}(z,r,\phi; t) - \frac{\mu}{\rho(z,r,\phi; t)} \nabla^2 \mathbf{u}(z,r,\phi; t) = \\
														- \frac{1}{\rho (z,r,\phi; t)} \nabla P(z,r,\phi; t) + \mathbf{F}(z,r,\phi; t), \label{eq:mass} 
\end{multline}
\begin{equation}
	z \in \mathbb{R}, \ r \in \mathbb{R}_{\geq 0}, \ \phi \in [0, 2\pi), \ \nabla := \left[\frac{\partial}{\partial z}, \frac{1}{r}\frac{\partial}{\partial r}r, \frac{1}{r}\frac{\partial}{\partial \phi}  \right].
\end{equation}
Here $\rho$ and $\mu$ are the blood density and viscosity mentioned in section \ref{sec:b}, 
\begin{equation}
	\mathbf{u}(z,r,\phi; t) := \left[ u_z(z,r,\phi; t), u_r(z,r,\phi; t), u_\phi (z,r,\phi; t) \right]^T
\end{equation}
is the velocity field, $P$ is the pressure, and $\mathbf{F}$ is any force acting on the fluid system.
\autoref{eq:cont} is also referred to as the continuity equation \cite{anderson2011ebook}.
Usually the Navier-Stokes equations (NSE) are considered to be made up of \autoref{eq:cont} and \autoref{eq:mass} as well as the energy equation.
In our case the energy equation can be omitted due to us considering an incompressible Newtonian fluid and therefore there not being any temperature gradients in the fluid and there being no heat flux by conduction.
Furthermore, we also assume that heat generated by friction is negligible and that there are no heat sources.
Finally, wall displacement will be considered small enough for the work to be done by it on the fluid to be negligible. 
For these reasons the energy equation can be omitted in our model.
We will also make further assumptions on vessel geometry and material properties.

We consider a vessel to be an axisymmetric tube along the $z$ axis in a cylindrical coordinate system $\left(z,r,\phi\right)$.
Under the following assumptions the 3D-Navier-Stokes equations can be reduced to a 1D-model:

\begin{enumerate}
	\item Blood is an incompressible Newtonian fluid and it's properties do not vary over a cross-section. \label{it:fld} 
	\item Vessel walls can be displaced slightly in radial direction but not in longitudinal direction, \label{it:displ} 
	\item Vessels are narrow, long, and circular, \label{it:nlc}
	\item Vessels are straight and have linearly elastic compliant walls, \label{it:lec}
\end{enumerate}
In order to make this reduction we first apply the assumption that $\rho$ is constant (\autoref{it:fld}) in the continuity equation and expand the momentum equation in it's components
\begin{equation}
	\frac{\partial u_z}{\partial z} + \frac{1}{r} \frac{\partial (ru_r)}{\partial r} + \frac{1}{r}\frac{\partial u_\phi}{\partial \phi} = 0, 
\end{equation}
\begin{multline}
	\frac{\partial u_z}{\partial t} + u_z \frac{\partial u_z}{\partial z} + u_r \frac{\partial u_z}{\partial r} + \frac{u_\phi}{r}\frac{\partial u_z}{\partial \phi} = \\
	-\frac{1}{\rho}\frac{\partial P}{\partial z} + \frac{\mu}{\rho} \left( \frac{\partial^2 u_z}{\partial z^2} + \frac{\partial^2 u_z}{\partial r^2} + \frac{1}{r} \frac{\partial u_z}{\partial r} + \frac{1}{r^2}\frac{\partial^2 u_z}{\partial \phi^2} \right), 
\end{multline}
\begin{multline}
	\frac{\partial u_r}{\partial t} + u_z \frac{\partial u_r}{\partial z} + u_r \frac{\partial u_r}{\partial r} + \frac{u_\phi}{r}\frac{\partial u_r}{\partial \phi} -\frac{u_\phi^2}{r} = \\
	-\frac{1}{\rho}\frac{\partial P}{\partial r} + \frac{\mu}{\rho} \left( \frac{\partial^2 u_r}{\partial z^2} + \frac{\partial^2 u_r}{\partial r^2} + \frac{1}{r} \frac{\partial u_r}{\partial r} + \frac{1}{r^2}\frac{\partial^2 u_r}{\partial \phi^2} -\frac{2}{r^2}\frac{\partial u_\phi}{\partial \phi} - \frac{u_r}{r^2} \right), 
\end{multline}
\begin{multline}
	\frac{\partial u_\phi}{\partial t} + u_z \frac{\partial u_\rho}{\partial z} + u_r \frac{\partial u_\phi}{\partial r} + \frac{u_\phi}{r}\frac{\partial u_\phi}{\partial \phi} -\frac{u_r u_\phi}{r} = \\
	-\frac{1}{\rho}\frac{\partial P}{\partial \phi} + \frac{\mu}{\rho} \left( \frac{\partial^2 u_\phi}{\partial z^2} + \frac{\partial^2 u_\phi}{\partial r^2} + \frac{1}{r} \frac{\partial u_\phi}{\partial r} + \frac{1}{r^2}\frac{\partial^2 u_\phi}{\partial \phi^2} -\frac{2}{r^2}\frac{\partial u_r}{\partial \phi} - \frac{u_\phi}{r^2}\right). \label{eq:momp}
\end{multline}
Here we have dropped the explicit dependence on time and space variables in favour of readability.
Since the model is considered to be axisymmetric we set $v_\phi=0$ and ignore derivatives in this direction.
This means we can drop \autoref{eq:momp}.
The remaining three equations read
\begin{equation}
	\frac{\partial u_z}{\partial z} + \frac{1}{r} \frac{\partial (r u_r)}{\partial r} = 0, \label{eq:cont1}
\end{equation}
\begin{equation}
	\frac{\partial u_z}{\partial t} + u_z \frac{\partial u_z}{\partial z} + u_r \frac{\partial u_z}{\partial r} = -\frac{1}{\rho} \frac{\partial P}{\partial z} + \frac{\mu}{\rho} \left( \frac{\partial^2 u_z}{\partial z^2} + \frac{\partial^2 u_z}{\partial r^2} + \frac{1}{r} \frac{\partial u_z}{\partial r} \right),
\end{equation}
\begin{equation}
	\frac{\partial u_r}{\partial t} + u_z \frac{\partial u_r}{\partial z} + u_r \frac{\partial u_r}{\partial r} = -\frac{1}{\rho} \frac{\partial P}{\partial r} + \frac{\mu}{\rho} \left( \frac{\partial^2 u_r}{\partial z^2} + \frac{\partial^2 u_r}{\partial r^2} + \frac{1}{r} \frac{\partial u_r}{\partial r} - \frac{u_r}{r^2}\right). \label{eq:momr}
\end{equation}
In order to simplify the equations we introduce typical velocities $U_z$ and $U_r$ and define the non-dimensional quantities as
\begin{equation}
	\tilde{r} := \frac{r}{r_0}, \ \tilde{z} := \frac{z}{l_0}, \ \tilde{t} := t \frac{U_z}{l_0}, \ \tilde{u}_z := \frac{u_z}{U_z}, \ \tilde{u}_r := \frac{u_r}{U_r}, \ \tilde{P} := \frac{P}{\rho U_z^2}, \ \epsilon := \frac{U_r}{U_z}.
\end{equation}
We note that in a laminar flow the maximum value of $U_r$ is the radial velocity of the arterial wall.
As we assume that these walls can only be displaced slightly (\autoref{it:displ}), $U_r$ can be assumed to be small and therefore $\epsilon << 1$. \cite{womersley1957elastic}
Inserting the non-dimensional into \autoref{eq:cont1} - \autoref{eq:momr} and dropping the terms of order $\epsilon^2$ or higher yields
\begin{equation}
	\frac{\partial (\tilde{r} \tilde{u}_r)}{\partial \tilde{r}} + \frac{\partial (\tilde{r} \tilde{u}_z)}{\partial\tilde{z}} = 0, \label{eq:cont2}
\end{equation}
\begin{equation}
	\tilde{r} \frac{\partial \tilde{u}_z}{\partial \tilde{t}} + \frac{ \partial (\tilde{r} \tilde{u}_z^2)}{\partial \tilde{z}} + \frac{ \partial (\tilde{r} \tilde{u}_z \tilde{u}_r)}{\partial \tilde{r}} + \tilde{r} \frac{\partial \tilde{P}}{\partial \tilde{z}} = \frac{\mu}{\rho} \frac{l_0}{U_z r_0^2} \frac{\partial}{\partial \tilde{r}} \left( \tilde{r} \frac{\partial \tilde{u}_z}{\partial \tilde{r}} \right), \label{eq:momz}
\end{equation}
\begin{equation}
	\frac{\partial \tilde{P}}{\tilde{r}} = 0.
\end{equation}
Introducing the non-dimensional vessel inner radius $\hat r$, the averaged velocity over the circular (\autoref{it:nlc}) cross-section
\begin{equation}
	\hat{u} := \frac{1}{\hat{r}^2} \int_0^{\hat{r}} 2 \tilde{u}_z \tilde{r} d\tilde{r},
\end{equation}
and the Coriolis' coefficient
\begin{equation}
	\alpha := \frac{1}{\hat{r}^2 \hat{u}} \int_0^{\hat{r}} 2 \tilde{u}_z^2 \tilde{r} d\tilde{r},
\end{equation}
can be defined.
The Coriolis' coefficient is the correction parameter that stems from the fact that our new momentum equation no longer expresses the conservation of momentum but actually the conservation of the momentum averaged over the radial component.\cite{article10002407}
Using these definitions and applying the no-slip boundary condition while assuming negligible longitudinal wall displacement (\autoref{it:displ})
\begin{equation}
	\tilde{u}_r|_{\tilde{r}=\hat{r}} = \frac{\partial \hat{r}}{\partial \tilde{t}},
\end{equation}
the equations \autoref{eq:cont2} and \autoref{eq:momz} read
\begin{equation}
	\hat{r} \frac{\partial \hat{r}}{\partial \tilde{t}} + \frac{1}{2}\frac{\partial}{\partial \tilde{z}} \left(  \hat{u}\hat{r}^2 \right) = 0, \label{eq:cont3}
\end{equation}
\begin{equation}
	\frac{(\partial \hat{r}^2 \hat{u})}{\partial \tilde{t}} + \frac{\partial \left( \alpha \hat{r}^2 \hat{u}^2 \right)}{\partial \tilde{z}} + \hat{r}^2 \frac{\partial \tilde{P}}{\partial \tilde{z}} = 2\frac{\mu}{\rho} \frac{l_0}{U_z r_0^2} \hat{r} \frac{\partial \tilde{u}_z}{\partial \tilde{z}} |_{\hat{r}}.\label{eq:momz1}
\end{equation}
After reintroducing a dimensional axial velocity in terms of the dimensional inner vessel radius $\bar{r}$
\begin{equation}
	u := U_z \hat{u} = \frac{1}{\bar{r}^2} \int_0^{\bar{r}} 2su_zds,
\end{equation}
we can also write the Coriolis' coefficient in terms of dimensional variables
\begin{equation}
	\alpha = \frac{1}{\bar{r}^2 u^2} \int_0^{\bar{r}} 2ru_z^2dr.
\end{equation}
In dimensional variables the continuity equation (\autoref{eq:cont3}) and the $z$-momentum equation (\autoref{eq:momz1}) are
\begin{equation}
	\frac{\partial \bar{r}^2}{\partial t} + \frac{\partial (\bar{r}^2 u^2)}{\partial z} = 0,
\end{equation}
\begin{equation}
	\frac{\partial (\bar{r}^2 u)}{\partial t} + \frac{\partial (\alpha \bar{r}^2 u^2) }{\partial z} + \frac{\bar{r}^2}{\rho} \frac{\partial P}{\partial z} = 2 \frac{\mu}{\rho} \bar{r} \frac{\partial u_z}{\partial r} |_{\bar{r}}.
\end{equation}
In terms of the cross-section $A := \pi \bar{r}^2$ (\autoref{it:nlc}) and the volumetric flow-rate $Q := Au$ the 1D-NSE finally read
\begin{equation}
		\frac{\partial A(z;t)}{\partial t} + \frac{\partial Q(z;t)}{\partial z} = 0, \label{eq:1deqs1}
\end{equation}
\begin{multline}
		\frac{\partial Q(z;t)}{\partial t} + \frac{\partial}{\partial z}\left(\alpha(z;t) \frac{Q(z;t)^2}{A(z;t)} \right) + \frac{A(z;t)}{\rho(z;t)} \frac{\partial P(z;t)}{\partial z} = \\
		-2 \frac{\mu}{\rho(z;t)} ( \gamma + 2 ) \frac{Q(z;t)}{A(z;t)}, \label{eq:1deqs2}
\end{multline}
\begin{equation}
		z \in [0,l],\  t \in \mathbb{R}_{\geq 0}, 
\end{equation}
where we have reintroduced the time and space dependency for clarity.
Here $\gamma$ is the velocity profile parameter that determines the velocity profile by a common parametric approximation 
\begin{equation}
	u_z(z,r;t) := \frac{\gamma + 2}{\gamma} u(z;t) \left[ 1 - \left( \frac{r}{\bar{r}(z;t)} \right) \right].
\end{equation}
For this velocity profile the Coriolis coefficient is
\begin{equation}
	\alpha = \frac{\gamma + 2}{\gamma + 1}.
\end{equation}
For $\gamma=2$, $\alpha = \frac{4}{3}$ this gives a plug flow, a rather flat velocity profile that decays rapidly at the artery walls.
For $\gamma=9$, $\alpha = \frac{11}{10} $ we get a hyperbolic velocity profile and hence a Poiseuille-like flow. \cite{köppl2023dimension} \cite{barnard1966theory}

We want to determine the variables $Q, A,$ and $P$.
Until now we've considered the two equations of mass and momentum conservation determining $Q$ and $A$.
In order to close the system and determine $P$ we therefore need another equation, a so-called tube law.
There are many different ways to model the pressure $P$ within a deforming tube and there is no way that is considered the de facto right way.
For a full comparison of a wide range of such models we refer to \cite{gomez2017analysis}.
In the model used in this work the pressure $P$ is given by the external pressure $P_{ext}$ stemming from surrounding tissue as well as the pressure from the deformation of the vessel
\begin{equation}
	P_{def}(z;t) := \frac{h_0(z) \sigma(z;t)}{\pi r(z;t)}, \label{eq:pdef}
\end{equation}
given by the Young-Laplace law \cite{comte1799traite} \cite{thomas1805essay}.
Here $\sigma$ is the stress which describes the internal forces that neighbouring particles of the continuous material exert on each other.
Assuming linear elasticity (\autoref{it:lec}) and using Hooke's law \cite{hooke1678lectures} we arrive at
\begin{equation}
	\sigma(z;t) := \epsilon(z;t) E \label{eq:stress},
\end{equation}
where $E$ describes the stiffness of the elastic material and is called Young's modulus.
The quantity $\epsilon$ is referred to as the stress and models the deformation of the material.
Assuming an isotropic, homogeneous, and incompressible arterial wall, an axisymmetric deformation, and circular cross-sections (\autoref{it:nlc}) that are independent of each other $\epsilon$ is given by
\begin{equation}
	\epsilon(z;t) := \frac{r(z;t)-r_0(z;t)}{ (1-\nu^2) r_0(z;t)}. \label{eq:strain}
\end{equation}
In this definition, $\nu$ is the elasticity parameter or Poisson's ratio.
It is the ratio of transverse contraction to longitudinal extension strain in the direction of the stretching force.
Combining \autoref{eq:pdef}-\autoref{eq:strain} with a term for the external pressure $P_{ext}$ we get \cite{sherwin2003one} \cite{sherwin2003computational}
\begin{align}
	P(z;t) &:= P_{ext}(z;t) + \beta \left( \sqrt{\frac{A(z;t)}{A_0(z)}}-1 \right),  \label{eq:p_tot}\\
	\beta(z) &:=  \frac{\sqrt{\pi} E h_0(z)}{(1-\nu^2) \sqrt{A_0(z)}}.
\end{align}
We refer to $\beta$ as the elasticity coefficient from here on out.
Comparison with experimental data shows that a plug-flow is a reasonable approximation of the velocity profile \cite{hunter1972numerical} \cite{smith2000generation} \cite{smith2002anatomically}.
Therefore it is reasonable to set $\gamma = 9, \alpha = \frac{11}{10}$.
Since the plug-flow velocity profile is relatively flat, the average of $Q$ doesn't differ from the actual value anywhere along $r$.
Therefore, we can also set the Coriolis' coefficient $\alpha$ (averaging correction parameter) to $\alpha = 1$. \cite{formaggia2010cardiovascular}
Inserting these fixed values for $\gamma$ and $\alpha$ into \autoref{eq:1deqs1} and \autoref{eq:1deqs2} leads to 
\begin{equation}
	\begin{aligned} 
		\frac{\partial A}{\partial t} + \frac{\partial Q}{\partial z} &= 0, \\ 
		\frac{\partial Q}{\partial t} + \frac{\partial}{\partial z}\left(\frac{Q^2}{A} \right) + \frac{A}{\rho} \frac{\partial P}{\partial z} &= -22 \frac{\mu}{\rho} \frac{Q}{A}.
	\end{aligned} \label{1deqs2}
\end{equation}
where from here on out we have dropped the space and time dependence.
We can rewrite equation \ref{1deqs2} in it's conservative form by defining the following shorthand:

\begin{equation}
	\mathbf{U} := 
	\begin{bmatrix}
		A \\
		Q
	\end{bmatrix},
\end{equation}

\begin{equation}
	\mathbf{F} \left( \mathbf{U} \right) := 
	\begin{bmatrix}
		Q \\
		\frac{Q^2}{A} + \frac{\beta A^{\frac{3}{2}}}{3\rho\sqrt{A_0}}
	\end{bmatrix},
\end{equation}

\begin{equation}
	\mathbf{S} \left( \mathbf{U} \right) := 
	\begin{bmatrix}
		0 \\
	-22\frac{\mu}{\rho}\frac{Q}{A} 
	\end{bmatrix},
\end{equation}
where we have inserted \autoref{eq:p_tot} for $P$ and we have set Poisson's ration $\nu = \frac{1}{2}$ since biological tissue is nearly incompressible \cite{sherwin2003one}.
The conservative form then reads:
\begin{equation}
	\begin{aligned}
		\frac{\partial \mathbf{U}}{\partial t} + \frac{\partial \mathbf{F} \left( \mathbf{U} \right)}{\partial z} &= \mathbf{S} \left( \mathbf{U} \right), \ t>0, \ z \in \left[ 0,l \right], \\
		\mathbf{U} \left( z;0 \right) &= \mathbf{U}_0 \left( z \right), \ z \in \left[ 0,l \right], \\
		\mathbf{U} \left( 0;t \right) &= \mathbf{U}_L \left( t \right), \ t>0,\\
		\mathbf{U} \left( l;t \right) &= \mathbf{U}_R \left( t \right), \ t>0,
	\end{aligned} \label{eq:1deqs3}
\end{equation}
where we have added initial values $\mathbf{U}_0$ and boundary conditions $\mathbf{U}_L$ and $\mathbf{U}_R$ so that equation \ref{eq:1deqs3} now yields a well posed problem.\cite{formaggia2010cardiovascular}
This concludes the description of the 1D-model for a single artery.
The explicit setting of the aforementioned initial conditions and boundary values needs to be modelled as well.
However, we will address this in \autoref{sec:icbc} of the next chapter after introducing our numerical methods and some notations that will make it easier to describe the assigning of initial conditions and boundary values.





\chapter{Numerical Methods} \label{chap:nm}
The numerical realization of the 1D-model within a single vessel described in \autoref{sec:sv} is achieved using a Finite Volume (FV) method to solve the homogeneous part of the equation \autoref{eq:1deqs3}, while the source term is accounted for by using a forward Euler time-step. 
The FV method that was applied here is the monotonic upstream-centred scheme for conservation laws (MUSCL).
The initial data, inlets, junctions, and outlets of the system are set from data, in accordance with neighbouring vessels, or through a reflective or a Windkessel model.

In this chapter we will first discuss the different approaches taken to solve the previously described 1D-model and why we chose the FV method in \autoref{sec:lr}.
We will then describe the FV method and state the specific MUSCL scheme we used in \autoref{sec:fv} and \autoref{sec:muscl}.
Thereafter we briefly describe the forward Euler time-step used to accommodate the inhomogeneous part of our 1D-equations in \autoref{sec:fe} and finally we state how we applied initial conditions and boundary values in \autoref{sec:icbc}.

\section{Literature Review} \label{sec:lr}
The governing equations derived in \autoref{sec:sv} have mainly been approached numerically in four different manners.
Namely through the method of characteristics or finite difference (FD), finite volume (FV), or finite element (FE) schemes.
Using the method of characteristics, the hyperbolic PDE that describes the haemodynamics is rewritten as an ODE of the Riemann invariants of the system along the corresponding characteristic lines.
This method was used in \cite{streeter1963pulsatile,bodley1971non,parker1990forward,wang2004wave,wang2003time}.
A finite difference scheme was applied by \cite{smith2002anatomically,elad1991numerical,elad1991numerical,pontrelli2003numerical,reymond2009validation}.
The finite volume and the finite element methods have become more prevalent in recent years.
The advantage of the FV solver over the FD solver is that they can treat discontinuities \cite{toro2001shock}, i.e. they can deal with potential large gradients occurring in the solution \cite{shu1988efficient,harten1997uniformly}.
In the case of our simulation, these might occur when assigning boundary values and therefore a FV method would be beneficial.
The finite volume method was applied by \cite{melis2017gaussian,brook1999numerical,brook2002model} and the finite element method has been used in \cite{sherwin2003one,sherwin2003computational,formaggia2001coupling,wan2002one,porenta1986finite,rooz1982finite,bessems2008experimental}.
While higher accuracy and faster convergence can technically be achieved by a FE method, there are applications in venous systems where FE schemes do not converge.
There is also increasing complexity involved when implementing models that are based on the method of characteristics all the way up to finite element methods.
For this work we chose to implement the haemodynamics solver using a FV scheme, specifically using the MUSCL solver.
The reason for this is that the FV solver offers many benefits when applied to hyperbolic systems.
The 1D-NSE (\autoref{eq:1deqs3}) is a hyperbolic PDE, i.e. these equations describe phenomena where information travels at finite speeds. 
Some of the benefits of using FV methods to solve hyperbolic systems are the ability of these methods to be shock capturing and to be inherently conservative.
They therefore offer enough accuracy to model the problem while having the added benefit of reduced complexity when comparing them to a FE implementation.
Offering enough accuracy therefore, the FV method was the most straight forward one towards a differentiable 1D-haemodynamics solver.


\section{Finite Volume (FV)} \label{sec:fv}
In order to describe the FV method that was applied to solve \autoref{eq:1deqs3} we will first introduce a space and time discretization.
The space discretization is defined as follows
\begin{align}
	&0 = z_0 < z_1 < z_2 < ... < z_N = l, \\
	&z_i :=  i \Delta z,\ i \in \{0,1,...,N\} , \\
	&\Delta z := \frac{l}{N}.
\end{align}
For the time discretization a time-step series is defined
\begin{align}
	0 < t^1 < t^2 < t^3 < ...\ ,
\end{align}
where the explicit computation of the values of $t^n$, $n \in \mathbb{N}$  will be given in \autoref{sec:cfl}.
The balance equation on the infinitesimal control volume 
\begin{align}
	&[\tilde{z}, \tilde{z} + \delta z] \times [\tilde{t}, \tilde{t} + \delta t], \\
	&\tilde{z} \in (0,l), \\
	&\tilde{t} > 0,
\end{align}
for a hyperbolic law in it's conservation form \cite{guinot2012wave} (e.g. \autoref{eq:1deqs3}) is given by
\begin{multline}
	\int_{\tilde{z}}^{\tilde{z} + \delta z} \mathbf{U} (z; \tilde{t} + \delta t) - \mathbf{U} (z;\tilde{t}) dz = \int_{\tilde{t}}^{\tilde{t}+\delta t} \mathbf{F}(\tilde{z};t) - \mathbf{F}(\tilde{z} + \delta z; t) dt\\
																											   + \int_{\tilde{t}}^{\tilde{t} + \delta t} \int_{\tilde{z}}^{\tilde{z} + \delta z}  \mathbf{S}(z;t) dzdt.
\end{multline}
For the specific control volume, also referred to as cell $i$,
\begin{align}
	&[z_{i-\frac{1}{2}},z_{i+\frac{1}{2}}] \times [t^n, t^{n+1}], \\
	&\Delta t := t^{n+1}-t^n,
\end{align}
where $z_{i \pm \frac{1}{2}}$ are the spatial points exactly in-between $z_{i}$, $z_{i+1}$ and $z_{i-1}$, $z_{i}$ respectively, the balance equation yields
\begin{equation}
	(\mathbf{U} _i^{n+1}-\mathbf{U} _i^n) \Delta z = (\mathbf{F}_{i-\frac{1}{2}}^{n+\frac{1}{2}} - \mathbf{F}_{i+\frac{1}{2}}^{n+\frac{1}{2}}) \Delta t + \mathbf{S}_i^{n+\frac{1}{2}} \Delta z \Delta t.
\end{equation}
Here $\mathbf{U}_i^n$, $i \in \{0,1,...,N\}$ is the average of $\mathbf{U}$ over the spatial component of the cell $i$ at time-step $n$,
$\mathbf{F}_{i \pm \frac{1}{2}}^{n + \frac{1}{2}}$ is the average of the flux $\mathbf{F}$ where the cells $i$ and $i+1$, or  $i-1$ and $i$  meet exactly in-between the time-steps $n$ and $n + 1$, and $\mathbf{S}_i^{n+\frac{1}{2}}$ is the average of the source term $\mathbf{S}$ over the spatial component of the cell, again at the time-step right in-between $n$ and $n+1$.
Dividing by $\Delta z$ and rearranging the terms gives
\begin{equation}
	\mathbf{U} _i^{n+1} = \mathbf{U}_i^n + \frac{\Delta t}{\Delta z} (\mathbf{F}_{i-\frac{1}{2}}^{n+\frac{1}{2}} - \mathbf{F}_{i+\frac{1}{2}}^{n+\frac{1}{2}}) + \mathbf{S}_i^{n+\frac{1}{2}} \Delta t. \label{eq:fv}
\end{equation}
Therefore the value of $\mathbf{U}$ at the next time-step $n+1$ can be determined from the value at the current time-step $n$ and the values of the flux $\mathbf{F}$ and the source term $\mathbf{S}$ at the intermediate time-step $n + \frac{1}{2}$. \cite{guinot2012wave}
In the following section we will discuss how to compute the flux terms.

\section{MUSCL} \label{sec:muscl}
The MUSCL scheme was developed by Van Leer towards the end of the 1970s \cite{van1977towards} \cite{van1979towards}.
The version represented here is the most commonly used one.
This MUSCL solver consists of 4 steps:
\begin{enumerate}
	\item Reconstructing a plausible $\mathbf{\hat{U}}(z;t^n)$ for $z \in [z_{i-\frac{1}{2}}, z_{i+\frac{1}{2}}]$ from $\mathbf{U}_i^n$.
	\item Limiting the profile of said reconstruction, as to be "Total Variation Diminishing" (TVD), this is often also referred to as slope limiting.
	\item Solving a generalized Riemann problem.
	\item Using the solution of this Riemann problem to compute $\mathbf{U}_i^{n+1}$, also referred to as balancing over the cells.
\end{enumerate}
We will describe these steps more closely in \autoref{ssec:reco} - \autoref{ssec:grp}.
\subsection{Reconstruction} \label{ssec:reco}
When reconstructing a solution within a cell $\mathbf{\hat{U}}(z;t^n), z \in [z_{i-\frac{1}{2}}, z_{i+\frac{1}{2}}]$ with respect to the computed average of that cell $\mathbf{U}_i^n$, conservation has to be taken into account.
This means that the average of the reconstruction over the cell needs to be the same as the average it was reconstructed from 
\begin{equation}
	\frac{1}{\Delta z} \int_{z_{i-\frac{1}{2}}}^{z_{i+\frac{1}{2}}} \mathbf{\hat{U}}_i^n(z;t^n) dz = \mathbf{U}_i^n.
\end{equation}
The reconstruction in this MUSCL scheme is chosen to be the following linear expression
\begin{align}
	\mathbf{\hat{U}}(z;t^n) &= \mathbf{U}_i^n + (z-z_i)a_i^n, \\
	a_i^n &= \frac{\mathbf{U}_{i+1}^n - \mathbf{U}_{i-1}}{z_{i+1} - z_{i-1}}.
\end{align}
\subsection{Profile Limiting} \label{ssec:pl}
We define the total variation of the numerical solution $\mathbf{U}_i^n$ at time-step $n$ to be 
\begin{equation}
	TV(\mathbf{U})^n = \sum_{i=0}^{N-1} | \mathbf{U}_{i+1}^n - \mathbf{U}_{i}^n|.
\end{equation}
A numerical scheme is "Total Variation Diminishing" (TVD) if the following holds
\begin{equation}
	TV(\mathbf{U})^{n+1} \leq TV(\mathbf{U})^n.
\end{equation}
According to \cite{van1977towards} and \cite{colella1984piecewise} the MUSCL scheme is TVD if it satisfies
\begin{align}
	\min (\mathbf{U}_{i-1}^n, \mathbf{U}_i^n) &\leq \mathbf{\hat{U}}_i^n(z_{i-\frac{1}{2}}) \leq \max (\mathbf{U}_{i-1}^n, \mathbf{U}_i^n), \label{eq:tvd1}\\
	\min (\mathbf{U}_{i}^n, \mathbf{U}_{i+1}^n) &\leq \mathbf{\hat{U}}_i^n(z_{i+\frac{1}{2}}) \leq \max (\mathbf{U}_{i}^n, \mathbf{U}_{i+1}^n).\label{eq:tvd2}
\end{align}
This can be achieved by running the following checks:
\begin{enumerate}
	\item Cell $i$ is not a local extrema, i.e. $(\mathbf{U}_i^n - \mathbf{U}_{i-1}^n)(\mathbf{U}_{i+1}^n-\mathbf{U}_i^n) > 0$. \label{chk1}
	\item \autoref{eq:tvd1} is satisfied. \label{chk2}
	\item \autoref{eq:tvd2} is satisfied. \label{chk3}
\end{enumerate}
If \autoref{chk1} is not satisfied, $a_i^n$ is set to zero.
Thereafter \autoref{chk2} and \autoref{chk3} don't need to be checked.
If \autoref{chk1} is satisfied but \autoref{chk2} is not, $a_i^n$ is set to the biggest value allowed by \autoref{eq:tvd1}
\begin{equation}
	a_i^n = 2 \frac{\mathbf{U}_i^n - \mathbf{U}_{i-1}^n}{\Delta z}.
\end{equation}
Otherwise, if \autoref{chk3} is not satisfied, $a_i^n$ is set to the biggest value allowed by \autoref{eq:tvd2}
\begin{equation}
	a_i^n = 2 \frac{\mathbf{U}_{i+1}^n - \mathbf{U}_{i}^n}{\Delta z}.
\end{equation}

\subsection{Generalized Riemann Problem and Balancing} \label{ssec:grp}
In order to get a first approximation for the flux that needs to be computed, the Riemann problem
\begin{align}
	\frac{\partial \mathbf{U}}{\partial t} + \frac{\partial \mathbf{F}}{\partial z} &= 0, \\
	\mathbf{U}(z,t^n) &= \left\{
		\begin{array}{c}
			\mathbf{\hat{U}}_i^n(z_{i+\frac{1}{2}}) \text{, for } z < z_{i+\frac{1}{2}}, \\
			\mathbf{\hat{U}}_{i+1}^n(z_{i+\frac{1}{2}}) \text{, for } z > z_{i+\frac{1}{2}},
	\end{array} \right.  
	\end{align}
	has to be solved.
	This yields a flux $\mathbf{F^*}$ with which we compute our averaged quantities at the next half-time-step using \autoref{eq:fv}
	\begin{align}
		\mathbf{U}_{i+\frac{1}{2},L}^{n+\frac{1}{2}} &= \mathbf{\hat{U}}_i^n(z_{i+\frac{1}{2}}) + \frac{\Delta t}{2 \Delta z} \left( \mathbf{F^*}(\mathbf{\hat{U}}_i^n( z_{i-\frac{1}{2}})) - \mathbf{F^*}(\mathbf{\hat{U}}_i^n(z_{i+\frac{1}{2}}) \right),\\
		\mathbf{U}_{i+\frac{1}{2},R}^{n+\frac{1}{2}} &= \mathbf{\hat{U}}_i^n(z_{i+\frac{1}{2}}) + \frac{\Delta t}{2 \Delta z} \left( \mathbf{F^*}(\mathbf{\hat{U}}_{i+1}^n( z_{i+\frac{1}{2}})) - \mathbf{F^*}(\mathbf{\hat{U}}_i^n(z_{i+\frac{3}{2}}) \right),
	\end{align}
	where we have ignored the source term $\mathbf{S}$ for the moment.
	The resulting $\mathbf{U}_{i+\frac{1}{2},L}^{n+\frac{1}{2}}$ and $\mathbf{U}_{i+\frac{1}{2},R}^{n+\frac{1}{2}}$ are then used as left and right states of a new Riemann problem.
	The flux from this Riemann problem is again inserted into \autoref{eq:fv} giving the final value for $\mathbf{U}_i^{n+1}$.
	The fluxes that are computed in both Riemann problems mentioned in this section are not solved for analytically but numerically, using the conservative form of the Lax-Friedrichs scheme.
	Given that the flux function is Lipschitz continuous, this scheme is conservative and consistent \cite{köppl2023dimension}.
	In general it is first order accurate and stable for small enough step sizes (see \autoref{sec:cfl}). \cite{leveque1992numerical}
	We denote the computed approximation for $\mathbf{U}$ at time-step $n+1$ by $\bar{\mathbf{U}}^{n+1}$.
	In the next section we will be addressing how to handle the source term $\mathbf{S}$ that we have ignored here.

	\section{Time-stepping the source term} \label{sec:fe}
	In the previous section we have ignored the source term $\mathbf{S}$.
	To account for the source term, the following problem has to be solved
	\begin{equation}
		\frac{d \mathbf{U}}{d t}=\mathbf{S}(\mathbf{U}) .
	\end{equation}
	This is done here by using the forward Euler method \cite{köppl2023dimension}
	\begin{equation}
		\mathbf{U}^{n+1}=\bar{\mathbf{U}}^{n+1} + \Delta t \mathbf{S}\left(\bar{\mathbf{U}}^{n+1}\right).
	\end{equation}



	\section{Initial Conditions and Boundary Values} \label{sec:icbc}
	We need to consider initial conditions for each vessel in our system which we will address in \autoref{ssec:initial_conditions}.
	Furthermore, each vessel also needs to have boundary values set as described in \autoref{ssec:boundary_values}.
	For vessels at the edge of the network that get fed by the heart, we set the input values through data.
	For vessels within the network the boundary values are set in correspondence with the neighbouring vessels.
	For vessels at the edge at the network that provide blood to get capillary bed, the output values are set through either a reflection or a Windkessel model
	These three cases of boundary values that need to be set are descried in \autoref{sssec:inlets} - \autoref{sssec:junctions}.
	\subsection{Initial Conditions} \label{ssec:initial_conditions}
	It is difficult to determine useful initial conditions for a haemodynamics computation.
	What is usually done therefore is to simply set
	\begin{align}
		u(z;0) &\equiv 0, &z \in [0,l],\\
		A(z;0) &= A_0(z), &z \in [0,l], \\
		Q(z;0) &= u(z;0)A(z;0) \equiv 0, &z \in [0,l].
	\end{align}
	The pressure $P$ is then computed by \autoref{eq:p_tot}.
	The physically inaccurate initial conditions can lead to false values propagating when solving the system.
	Therefore the output of the solve is usually fed back into the simulation as a new initial condition until s stable state has been reached.
	The negative effect from bad initial conditions usually persists for only about 2-3 heartbeats as long as correct boundary values are set.\cite{formaggia2010cardiovascular}
	In the next subsection we discuss how to set these boundary values. 

	\subsection{Boundary Values} \label{ssec:boundary_values}
	Setting boundary values depends on where in the network a vessel is positioned.
	Vessels at the edges are set from data (inputs) or given by a reflective or a Windkessel model (outputs).
	Vessels within the network have their boundary values set by computing inlet/outlet compatibility with the neighbouring vessels.
	We will treat all these cases in the next three sub-subsections.

	\subsubsection{Inlets}\label{sssec:inlets}
	Usually vessels that are at the edge of the network and that have an inlet that is not connected to another vessel are considered to be fed by the heart.
	Here the inlet is set through pre-computed data.
	This data either represents the pressure $P_L(t)$ or the volumetric flow $Q_L(t)$ being put out by the heart and is assigned in one of the following two ways
	\begin{align}
		P(0,t) &= P_L(t), &t \in [0,\infty), \\
		Q(0,t) &= Q_L(t), &t \in [0,\infty).
	\end{align}
	If one of these quantities is given at a time $t^{n+1}$ the remaining quantities describig our system can be computed at $t^{n+1}$ as well using extrapolation of characteristics.
	By Riemann's method of characteristics\cite{riemann1860fortpflanzung} the equations governing our 1D-model (\ref{eq:p_tot},\ref{eq:1deqs3}) imply that changes in pressure and velocity propagate in the backward and forward direction at the speeds $u-c$ and $u+c$.
	These quantities are commonly referred to as Riemann invariants due to being constant along the characteristic curves \cite{sarra2003method}.
	For a given state of our system $A$, $Q$, we denote the backward and forward Riemann invariants by
	\begin{align}
		W_1(A,u) := u - c, \\
		W_2(A,u) := u + c,
	\end{align}
	with the wave speed $c(A) := \sqrt{\frac{\beta}{2\rho}\sqrt{A}}$.
	We define discretized Riemann invariants at time-step $n$ in cell $i$ along the lines of the discretization introduced in \autoref{sec:fv}
	\begin{align}
		W_{1,i}^n := W_1(A_i^n,u_i^n) &= u^n_i - 4c^n_i,\\
		W_{2,i}^n := W_2(A_i^n,u_i^n) &= u^n_i + 4c^n_i,
	\end{align}
	with $c^n_i := \sqrt{\frac{\beta_i}{2\rho}\sqrt{A_i^n}}$.
	Therefore, at the first and the second cell the two Riemann invariants read as
	\begin{align}
		W_{1,0}^n &= u^n_0 - 4c^n_0,\\
		W_{2,0}^n &= u^n_0 + 4c^n_0,\\
		W_{1,1}^n &= u^n_1 - 4c^n_1,\\
		W_{2,1}^n &= u^n_1 + 4c^n_1.
	\end{align}
	If the input data is given in as a volumetric flow, the Riemann invariants at the next time step are computed via the following update formula
	\begin{align}
		W_{1,0}^{n+1} &= W^n_{1,0} + (W^n_{1,1} - W^n_{1,0})(c^n_0-u^n_0) \frac{\Delta t}{\Delta x} \label{update1a},\\
		W_{2,0}^{n+1} &= \frac{2Q^{n+1}_0}{A^n_0} - W^{n+1}_{1,0}, \label{update2a}
	\end{align}
	where $Q^{n+1}_0$ is given through input data.
	This equates to linearly extrapolating the Riemann invariants at the first and second cell to meet the backwards and the forwards travelling characteristic curve of the second and first cell respectively.
	The missing input quantities are then computed from the new Riemann invariants as follows
	\begin{align}
		u_0^{n+1} &= \frac{W_{1,0}^{n+1} + W_{2,0}^{n+1}}{2}, \\
		c_0^{n+1} &= \frac{W_{2,0}^{n+1} - W_{1,0}^{n+1}}{4}, \\
		A_0^{n+1} &= \frac{Q_0^{n+1}}{u_0^{n+1}}, \\
		P_0^{n+1} &= P_{ext} + \beta \left( \sqrt{\frac{A_0^{n+1}}{A_{0,0}}} - 1 \right). 
	\end{align}
	where $A_{0,0}$ is the reference cross-section at the cell $i=0$.
	If the input data is given as a pressure wave, the Riemann invariants at the next time step are computed via the following update formula, again provided through a linear extrapolation
	\begin{align}
		W_{1,0}^{n+1} &= W^n_{1,0} + (W^n_{1,1} - W^n_{1,0})(c^n_0-u^n_0) \frac{\Delta t}{\Delta x} \label{update1b}, \\
		W_{2,0}^{n+1} &= \frac{2Q^{n}_0}{A^n_0} - W^{n+1}_{1,0} \label{update2b}.
	\end{align}
	The missing input quantities are then computed from the new Riemann invariants as follows
	\begin{align}
		u_0^{n+1} &= \frac{W_{1,0}^{n+1} + W_{2,0}^{n+1}}{2}, \\
		c_0^{n+1} &= \frac{W_{2,0}^{n+1} - W_{1,0}^{n+1}}{4}, \\
		A_0^{n+1} &= A_{0,0}\left(\frac{P_0^{n+1}-P_{ext}}{\beta}\right)^2,\\
		Q_0^{n+1} &= A_0^{n+1} u_0^{n+1},
	\end{align}
	where $P^{n+1}_0$ is given through input data.

	\subsubsection{Outlets} \label{sssec:outl}
	One of the most basic ways of setting outlet values is to use reflection coefficient to model how much of a wave leaves the vessel and how much gets reflected.
	In cases where this doesn't provide enough accuracy, Windkessel models are applied \cite {formaggia2010cardiovascular}.
	These models are constructed after the function of a water pump as described in \autoref{sec:aw} by considering an analogous electrical circuit.
	We introduce here a reflective and a three-parameter Windkessel model.

	\paragraph{Reflection} \label{par:refl}
	This is done equivalently to the inlet boundary conditions through linear extrapolation of characteristics
	\begin{align}
		W_{2,N}^{n+1}&=W_{2,N}^n+(W_{2,N-1}^n-W_{2,N-1}^n) (u_N^n+c_N^n) \frac{\Delta t}{\Delta x}, \label{eq:refl1}, \\
		W_{1,N}^{n+1}&=W_{1,N}^0-R_t (W_{2,N}^{n+1}-W_{2,N}^0), \label{eq:refl2}
	\end{align}
	where $R_t \in [-1,1]$ is the reflection coefficient.
	At $R_t = 0$ no reflection occurs.
	It is noted that \autoref{eq:refl1} follows directly from linear extrapolation while \autoref{eq:refl2} is constructed in order to transfer some of the forward characteristic curve to the backward one in order to model a reflection.
	The simulation quantities can be computed from the Riemann invariants as follows
	\begin{align}
		u_N^{n+1} &= \frac{W_{1,N}^{n+1} + W_{2,N}^{n+1}}{2}, \\
		c_N^{n+1} &= \frac{W_{2,N}^{n+1} - W_{1,N}^{n+1}}{4}, \\
		Q_N^{n+1} &= A_N^n u_N^{n+1}.
	\end{align}
	A more accurate method of computing the outlet boundary values is to use a Windkessel model.

	\paragraph{Windkessel} \label{par:wk}
	The three element Windkessel model or RCR model is applied to simulate the perfusion as described in \cite{CiCP-4-317}.
	Such models are referred to as lumped-parameter or 0D-models due to the lack of a spatial dependency.
	The concept behind this method of computing outlet values is the assumption of a state $A^*$, $u^*$ at time-step $n+1$ that results from the two states $A_L$, $u_L$ and $A_R$, $u_R$ at time-step $n$ to the left and the right respectively.
	The so-called virtual state $A^*$, $u^*$ therefore satisfies the following equations in it's Riemann invariants
	\begin{align}
		W_1(A^*,u^*) = W_1(A_R,u_R), \label{eq:vrmi1}\\
		W_2(A^*,u^*) = W_2(A_L,u_L). \label{eq:vrmi2}
	\end{align}
	Considering a terminal resistance model the virtual state has to satisfy
	\begin{equation}
		A^*u^* = \frac{P(A^*) - P_{ven}}{R}, \label{eq:tr1}
	\end{equation}
	where the constant $P_{ven}$ represents the venous pressure and $R$ models the resistive load resulting from omitted arteries, the capillary bed, and the venous network.
	The venous pressure in a healthy patient is only $8-12$ mmHg \cite{klingensmith2008washington}.
	In our simulation it was therefore usually set to $0$.
	Inserting \autoref{eq:p_tot} and \autoref{eq:vrmi2} into \autoref{eq:tr1} gives
	\begin{equation}
		f(A^*) := R \left(u_L + 4c(A_L) \right) A^* - 4Rc(A^*)A^* - \frac{\beta}{A_0} \left( \sqrt{A^*} - \sqrt{A} \right) P_{ven} = 0,\label{eq:tr2}
	\end{equation}
	where the wave speed $c$ of a cross-section $A$ is defined as in \autoref{sssec:inlets}.
	An additional term $P_{ext}$ for modelling exterior tissue pressure can be added yielding
	\begin{equation}
		f(A^*) := R \left(u_L + 4c(A_L) \right) A^* - 4Rc(A^*)A^* - \frac{\beta}{A_0} \left( \sqrt{A^*} - \sqrt{A} \right) P_{ven} - P_{ext} = 0.\label{eq:tr3}
	\end{equation}

	The compliance of the omitted vessels and the resistance of the capillaries can be represented by a $CR_2$ system
	\begin{equation}
		C \frac{dP_C}{dt} = A^*u^* - \frac{P_C-P_{ven}}{R_2},
	\end{equation}
	where $C$ represents the compliance and $P_C$ is the pressure at said compliance.
	This equation can be discretized using an explicit Euler scheme in order to compute the values of $P_C$
	\begin{equation}
		P_C^n = P_C^{n-1} + \frac{\Delta t}{C} \left(A_Lu_L - \frac{ \left( P_C^{n-1} - P_{ven} \right)}{R_2} \right). \label{eq:pc}
	\end{equation}
	In order for the wave exiting the vessel to arrive at the compliance without being reflected, we couple the terminal resistance model with the $CR_2$ model.
	This is done by setting $R=R_1$ and $P_{ven}=P_C$ in \autoref{eq:tr2}.
	Since $A_L$, $u_L$ represent the state at the end of the vessel they can therefore be set to $A_i^n$, $u_i^n$.
	The \autoref{eq:tr1} coupled with \autoref{eq:pc} can be solved with a Newton solver\cite{atkinson1991introduction} in order to receive $A^*$.
	Using \autoref{eq:p_tot}, \autoref{eq:tr1} and the computed value for $A^*$ we can compute $u^*$.
	Finally $A_i^{n+1}$, $u_i^{n+1}$ are set to $A^*$, $u^*$ respectively. \cite{alastruey2008reduced}

	The variables $R_1$, $C$, $R_2$ are parameters that have to be determined for each individual application and they are named after their analogous components in electrical circuit modelling by which this algorithm was constructed.
	Different networks can have very different parameters and their accurate computation is not trivial \cite{köppl2023dimension}.
	This is a prime example for the need of efficient calibration algorithms which this thesis aims to work towards by providing a differentiable solver.
	In the next section we will go over how to set boundary values for junctions between vessels.

	\begin{comment}
		At capillary level, the pressure is assumed to be zero, i.e. $P_{\text {out }}=0$ and the coupling is performed by assuming that an intermediate state $\left(A^*, u^*\right)$ generates from $\left(A_l, u_l\right)$
		45
		D outlet) and $\left(A_r, u_r\right)$ (0D inlet) (Alastruey et al., 2008).
		In order to compute the output value through the Windkessel model we introduce a linearized version of the equations describing the blood flow that is computed by integrating out the spatial component
		\begin{equation}
			A^* u^*\left(1+\frac{R_1}{R_2}\right)+C_c R_1 \frac{\partial\left(A^* u^*\right)}{\partial t}=\frac{P_e-P_{\text {out }}}{R_2}+C_c \frac{\partial P_e}{\partial t}, \label{wk_eq1}
		\end{equation}
		where $P_c$ is initialised to zero and, at each time step, computed as
		\begin{equation}
			C_c \frac{\partial P_c}{\partial t}=A^* u^*-\frac{P_c-P_{\text {out }}}{R_2}. \label{wk_eq2}
		\end{equation}
		We consider $\beta$ and $A_0$ to be the same on both sides of the $0 \mathrm{D} / 1 \mathrm{D}$ interface. This yields the non-linear equation
		\begin{equation}
			f\left(A^*\right)=A^* R_1\left(u_l+4 c_l\right)-4 A^* R_1 c^*-\frac{\beta}{A_0}\left(\sqrt{A^*}-\sqrt{A_0}\right)+P_c \label{wk_eq3}
		\end{equation}
		where $c_l$ and $c^*$ are the wave speeds calculated with $A_l$ and $A^*$ respectively. $A^*$ is inilised to $A_l$ and $f\left(A^*\right)=0$ is solved iteratively by means of Newton's method. Once $A^*$ is found, $u^*$ reads
		\begin{equation}
			u^*=\frac{P_e^*-P_{o u t}}{A^* R_1}
		\end{equation}
		where $P_e^*=P_e\left(A^*\right)$.
		The corresponding code can be found in 

		src/boundary\_conditions.jl:169-216.
		\begin{align}
			C\frac{d P_C^{n+1}}{d t}+Q_{M}^{n+1}-Q_M^{n+1}&=0, \label{eq:RLC1}\\
			{L}{\frac{d Q_M^{n+1}}{d t}}+P_{M}^n-P_C^{n+1}&=-R_2 Q_{M}^{n+1} \label{eq:RLC2}.
		\end{align}
		Introducing a finite difference for the derivatives in the equations \autoref{eq:RLC1} and \autoref{eq:RLC2} leads to
		\begin{align}
			C{\frac{P_C^{n+1}-P_C^{n}}{\Delta t}} &+ Q_M^{n+1}-Q_M^n = 0, \label{lin_disc1}\\ 
			L\frac{Q_M^{n+1}-Q_M^{n}}{\Delta t} &+ R_{2}Q_M^{n+1}+P_M^n-P_C^{n+1} = 0. \label{lin_disc2}
		\end{align}
		Using \ref{lin_disc2} to eliminate any occurrence of $Q_M^n$ \ref{lin_disc1} we get
		\begin{align}
			P_C^{n+1} = \left(R_2 + \frac{L}{\Delta t}\right) \left( - C \frac{P_C^{n+1} - P_C^{n}}{\Delta t} + Q_M^n\right)+ P_M^n - \frac{L}{\Delta t} Q_M^{n}
		\end{align}
		and then solving for $P_C^{n+1}$ gives
		\begin{multline}
			\left( 1+ \frac{C}{\Delta t}\left( R_2 + \frac{L}{\Delta t} \right) \right) P_C^{n+1} = \\
			\left( R_2 + \frac{L}{\Delta t} \right) \left( \frac{C}{\Delta t} P_C^n + Q_M^n \right) + P_M^n - \frac{L}{\Delta t} Q_M^n.
		\end{multline}
		Simplifying the equation and regrouping the terms gives
		\begin{equation}
			\phi P_{C}^{n+1}=R_2 \left( \frac{C}{\Delta t}P_C^{n} + Q_M^n+\frac{1}{L+R_{2}\Delta t}\left(\Delta t P_M^n-L Q_M^{n}\right) \right),
		\end{equation}
		with 
		\begin{equation}
			\phi=\frac{R_{2}C}{\Delta t}{\bf+}\frac{R_{2}\Delta t}{L{+}R_{2}\Delta t}. \label{RCL}
		\end{equation}
		This gives us an update formula through which we can compute new values of $P_C$ at each step.
		Since the inertia effect is negligible in the capillary bed we can set $L=0$ changing the update function for $P_C$ to 
		\begin{equation}
			\phi P_{C}^{n+1}=\frac{R_{2}C}{\Delta t}(P_{C})^{n}+R_{2} Q_M^n+P_M^n,
		\end{equation}
		with 
		\begin{equation}
			\phi = \frac{R_{2}C}{\Delta t} + 1. 
		\end{equation}
		Introducing the relation
		\begin{equation}
			Q_M^n={\frac{P_M^n-P_{\mathrm{C}}^{n}}{R_{1}}} \label{RCLR}
		\end{equation}
		turns our RCL-circuit into an RCLR-circuit.
		Introducing the extra resistance prevents non-physical reflection of incoming waves.
		We can rewrite \ref{RCLR} as 
		\begin{equation}
			Q_M^n={\frac{P_M^n-(P_{M})_{R C L R}}{R_{1}+{\frac{R_{2}}{\phi}}}}, 
		\end{equation}
		with 
		\begin{equation}
			\bigl(P_{M}\bigr)_{RCLR}=\bigl(P_{C}\bigr)^{n}-{\frac{R_{2}}{\phi}}Q_M^n.
		\end{equation}
		Inserting the tube law and simplifying we can derive a function whose roots correspond to the correct value for $A_M^{n+1}$
		\begin{multline}
			f(A_M^{n+1}) = \left(R_{1}+{\frac{R_{2}}{\phi}}\right)\left( \left(u_{M}^n+4c_{M}^n \right)A_M^{n+1}-4c_M^nA_M^{n+1} \right) \\
			-{\frac{\beta}{A_{0,M}}}\Big(\sqrt{A_M^{n+1}}-\sqrt{A_{0,M}}\Big)+(P_{M}^n)_{R C L R} =0. \label{wk_newton}
		\end{multline}

		Finally we can simplify \ref{wk_newton} by writing out $(P_{M})_{RCLR}$ and once more using that the outgoing Riemann invariant at the end of the vessel is equal to the incoming one of our intermediate state giving us
		\begin{multline}
			f\left(A_M^{n+1}\right) = A_M^{n+1} R_1\left(u_M^n+4 c_M^n\right)-4 A_M^{n+1} R_1 c_M^n\\
			-\frac{\beta}{A_{0,M}}\left(\sqrt{A_M^{n+1}}-\sqrt{A_{0,M}}\right)+P_C^n = 0. \label{wk_eq3}
		\end{multline}
		This equation can be solved using a Newton solver.
	\end{comment}

	\subsubsection{Junctions} \label{sssec:junctions}
	Three types of junctions are considered.
	Conjunctions: joining two vessels; bifurcations: splitting one vessel into two; and anastomosis: joining two vessels into one.
	We will describe the governing equations of the junction types in the next three paragraphs. 

	\paragraph{Conjunctions} \label{par:conjunctions}
	A conjunction is the outlet of a vessel connected to the inlet of another vessel.
	For all types of junctions three types of equations are taken into account - conservation of mass, pressure conservation, and extrapolation of characteristics.
	For the conjunctions, the conservation of mass leads to 
	\begin{equation}
		A_{1,N}^{n+1} u_{1,N}^{n+1} - A_{2,0}^{n+1} u_{2,0}^{n+1}=0,
	\end{equation}
	where $A_{1,N}^{n+1}$, $u_{1,N}^{n+1}$ and $A_{2,0}^{n+1}$, $u_{2,0}^{n+1}$ are the cross-section and the velocity at the outlet of the first vessel and the inlet of the second vessel respectively.
	The pressure conservation is given by 
	\begin{multline}
		\beta_{1,N} \left( \frac{\sqrt{A_{1,N}^{n+1}}}{\sqrt{A_{0,1,N}}}-1\right)+\frac{1}{2} \rho \left( u_{1,N}^{n+1} \right) ^2 \\
		-\beta_{2,0} \left( \frac{\sqrt{A_{2,0}^{n+1}}}{\sqrt{A_{0,2,0}}}-1\right)+\frac{1}{2} \rho \left( u_{2,0}^{n+1} \right)=0,
	\end{multline}
	where $\beta_{1,N}$, $A_{0,1,N}$ and $\beta_{2,N}$, $A_{0,2,0}$ are the elasticity coefficient and the reference cross-section at the outlet of the first vessel and the inlet of the second vessel respectively.
	The first and the second term represent the pressure coming from the arterial wall.
	The second and the third term describe the kinetic pressure stemming from the fluid itself.
	Finally, analogously as in \autoref{sssec:outl}, we introduce the virtual state $A^*$, $u^*$ that generates from the two states $A_L$, $u_L$ and $A_R$, $u_R$
	\begin{align}
		W_1^* := W_1(A^*,u^*) = W_1(A_R,u_R) = W_1(A_{2,0}^{n+1}, u_{2,0}^{n+1}), \\
		W_2^* := W_2(A^*,u^*) = W_2(A_L,u_L) = W_1(A_{1,N}^{n+1}, u_{1,N}^{n+1}).
	\end{align}
	This also equates to 
	\begin{align}
		W_1^* = u_{2,0}^{n+1} - 4c_{2,0}^{n+1} = u_{2,0}^{n+1} - 4k_{2,0} \left( A_{2,0}^{n+1} \right)^{\frac{1}{4}}, \\
		W_2^* = u_{1,N}^{n+1} + 4c_{1,N}^{n+1} = u_{1,N}^{n+1} + 4k_{1,N} \left( A_{1,N}^{n+1} \right)^{\frac{1}{4}}.
	\end{align}
	where $k_{l,i} := \sqrt{\frac{\beta_{l,i}}{2\rho}}$ for $l \in \{1,2\}$, $i \in \{0,1,...N\}$.
	This leads to the system of equations
	\begin{equation}
		\mathbf{f}(\mathbf{q}) := \left[\begin{array}{c}
				q_{1}+4 k_{1,N} q_{3}-W_{2}^* \\
				q_{2}-4 k_{2,0} q_{4}-W_{1}^* \\
				q_{1} q_{3}^4-q_{2} q_{4}^4 \\
				\beta_1\left(\frac{q_{3}^2}{A_{0,1,N}^{1 / 2}}-1\right)+\frac{1}{2} \rho q_{1}^2-\beta_2\left(\frac{q_{4}^2}{A_{0,2,0}^{1 / 2}}-1\right)-\frac{1}{2} \rho q_{2}^2
		\end{array}\right] \equiv 0, 
	\end{equation}
	where we have introduced the following notation in order to more easily write this system in a matrix-vector form
	\begin{align}
		\mathbf{q}&:= \{q_k\}_{k=1}^4 = \left[\begin{array}{llll}
				u_{1,N}^{n+1}, & u_{2,0}^{n+1}, & \left( A_{1,N}^{n+1}\right)^{1 / 4}, & \left( A_{2,0}^{n+1} \right)^{1 / 4}
		\end{array}\right]^T. 
			\end{align}
			The system is solved iteratively using the Newton method
			\begin{align}
				\mathbf{J} \cdot \delta \mathbf{q}^m &= -\mathbf{f}\left(\mathbf{q}^m\right), \\
				\mathbf{q}^{m+1} &= \mathbf{q}^m+\delta \mathbf{q}^m,
			\end{align}
			where $\mathbf{J}$ is the Jacobian

			\begin{equation}
				\mathbf{J}:=\left[\begin{array}{c c c c}{{{1}}}&{{0}}&{{{4}k_{1,N}}}&{{0}}\\ {{0}}&{{{1}}}&{{0}}&{{-4k_{2,0}}}\\ {{q_{c3}^{4}}}&{{-q_{c4}^{4}}}&{{4q_{c3}q_{3}^{3}}}&{{-4q_{c4}q_{c}^{3}}}\\ {{q_{c1}^{4}}}&{{-\rho q_{c2}}}&{{2\beta_{1}\frac{q_{c}}{A_{0,1,N}^{1/2}}}}&{{-2\beta_{2}\frac{q_{4}}{A_{0,2,N}^{42}}}}\end{array}\right].
			\end{equation}

			The quantities $W_{1,N}^*$ and $W_{2,0}^*$ in $\mathbf{f}$ are computed from the updated $\mathbf{q}$ at every iteration.
			The initial condition for the Newton solver is set by
			\begin{align}
				\mathbf{q}^0&:=\left[\begin{array}{llll}
						u_{1,N}^{n}, & u_{2,0}^{n}, & \left( A_{1,N}^{n}\right)^{1 / 4}, & \left( A_{2,0}^{n} \right)^{1 / 4}
				\end{array}\right]^T.
					\end{align}
					It is noted that the Jacobian only needs to be evaluated at $\mathbf{q}^0$ and can be reused at each iteration.
					This reduces the computational cost and is commonly referred to as a type of frozen Newton method. \cite{jin2010class,amat2013maximum,amat2018two}
					In the next section we will be describing how to compute boundary values at bifurcations.

					\paragraph{Bifurcations} \label{par:bifurcations}
					A bifurcation is a junction where one vessel outlet connects to two vessel inlets.
					For bifurcations, the same conservation laws are applied as for the conjunction, i.e. conservation of mass, conservation of pressure, and compatibility of the characteristic curves.
					This leads to the following system of equation
					\begin{equation}
						\mathbf{f}(\mathbf{q}):=\left[\begin{array}{c}
								q_{1}+4 k_{1,N} q_{4}-W_{1,N}^* \\
								q_{2}-4 k_{2,0} q_{5}-W_{2,0}^* \\
								q_{3}-4 k_{2,0} q_{6}-W_{3,0}^* \\
								q_{1} q_{4}^4-q_{2} q_{5}^4-q_{3} q_{6}^4=0 \\
								\beta_1\left(\frac{q_{4}^2}{A_{0,1,N}^{1 / 2}}-1\right)-\beta_2\left(\frac{q_{5}^2}{A_{0,2,0}^{1 / 2}}-1\right) \\
								\beta_1\left(\frac{q_{4}^2}{A_{0,1,N}^{1 / 2}}-1\right)-\beta_3\left(\frac{q_{6}^2}{A_{0,3,0}^{1 / 2}}-1\right) 
						\end{array}\right] \equiv 0, \label{syseq_bif}
					\end{equation}
					with the same shorthand notation as used when describing the conjunctions and the following vector of variables
					\begin{multline}
						\mathbf{q}:=\{q_k\}_{k=1}^6 = \left[
							\begin{array}{lll}
								u_{1,N}^{n+1}, & u_{2,0}^{n+1}, & u_{3,0}^{n+1},
						\end{array} \right. \\
						\left. \begin{array} {lll}    \left(A_{1,N}^{n+1}\right)^{\frac{1}{4}}, & \left(A_{2,0}^{n+1}\right)^{\frac{1}{4}}, & \left(A_{3,0}^{n+1}\right)^{\frac{1}{4}}
						\end{array}\right].
							\end{multline}
							In analogy to the conjunction the frozen Newton method is applied to solve the system.
							The Jacobian here reads as
							\begin{equation}
								\mathbf{J}:=\left[\begin{array}{c c c c c c}
										1&0&0&4k_{1,N}&0&0\\
										0&1&0&0&-4k_{2,0}&0\\
										0&0&1&0&0&-4k_{3,0}\\
										q_{4}^4 & -q_{5}^4 & -q_{6}^4 & 4q_{1}q_{4}^3 & -4q_{2}q_{5}^3 & -4q_{3}q_{6}^3 \\
										0 & 0 & 0 & 2\beta_1\frac{q_{4}}{A_{0,1,N}^{\frac{1}{2}}} & -2\beta_2\frac{q_{5}}{A_{0,2,0}^{\frac{1}{2}}} & 0\\
										0 & 0 & 0 & 2\beta_1\frac{q_{4}}{A_{0,1,N}^{\frac{1}{2}}} & -2\beta_3\frac{q_{6}}{A_{0,3,0}^{\frac{1}{2}}} & 0\\
									\end{array} 
								\right].
							\end{equation}
							In \ref{syseq_bif} the kinetic energy terms $\frac{1}{2} \rho u^2$ are neglected.
							According to \cite{Formaggia2003OnedimensionalMF} this can be done since it's contribution to total pressure is small compared to the other terms.
							In the next section we will show how the boundary values for an anastomosis are set.

							\paragraph{Anastomosis} \label{par:anastomosis}
							An anastomosis describes two vessel outlets connecting to a single vessel inlet.
							For the anastomosis, applying the extrapolation of characteristics, conservation of mass, and pressure conservation leads to the following system of equations
							\begin{equation}
								\mathbf{f}(\mathbf{q}):=\left[\begin{array}{c}
										q_{1}+4 k_{1,N} q_{4}-W_{1,N}^* \\
										q_{2}+4 k_{2,N} q_{5}-W_{2,N}^* \\
										q_{3}-4 k_{2,0} q_{6}-W_{3,0}^* \\
										q_{1} q_{4}^4+q_{2} q_{5}^4-q_{3} q_{6}^4=0 \\
										\beta_1\left(\frac{q_{4}^2}{A_{0,1,N}^{1 / 2}}-1\right)-\beta_3\left(\frac{q_{6}^2}{A_{0,3,0}^{1 / 2}}-1\right) \\
										\beta_2\left(\frac{q_{5}^2}{A_{0,2,N}^{1 / 2}}-1\right)-\beta_3\left(\frac{q_{6}^2}{A_{0,3,0}^{1 / 2}}-1\right)
								\end{array}\right] \equiv 0.
							\end{equation}
							Reusing the shorthand notation introduced when describing the conjunctions and the following vector of variables
							\begin{multline}
								\mathbf{q}:=\{q_k\}_{k=1}^6=\left[
									\begin{array}{lll}
										u_{1,N}^{n+1}, & u_{2,N}^{n+1}, & u_{3,0}^{n+1}, 
								\end{array} \right. \\
								\left. \begin{array}{lll}
										\left(A_{1,N}^{n+1}\right)^{\frac{1}{4}}, & \left(A_{2,N}^{n+1}\right)^{\frac{1}{4}}, & \left(A_{3,0}^{n+1}\right)^{\frac{1}{4}}
								\end{array} \right].
							\end{multline}
							The Jacobian used when solving the system with the frozen Newton method here is
							\begin{equation}
								\mathbf{J}:=\left[\begin{array}{c c c c c c}
										1&0&0&4k_{1,N}&0&0\\
										0&1&0&0&4k_{2,N}&0\\
										0&0&1&0&0&-4k_{3,0}\\
										q_{4}^4 & q_{5}^4 & -q_{6}^4 & 4q_{1}q_{4}^3 & 4q_{2}q_{5}^3 & -4q_{3}q_{6}^3 \\
										0 & 0 & 0 & 2\beta_1\frac{q_{4}}{A_{0,1,N}^{\frac{1}{2}}} & 0 & -2\beta_3\frac{q_{6}}{A_{0,3,0}^{\frac{1}{2}}} \\
										0 & 0 & 0 & 0 & 2\beta_2\frac{q_{5}}{A_{0,2,N}^{\frac{1}{2}}} &  -2\beta_3\frac{q_{6}}{A_{0,3,0}^{\frac{1}{2}}} \\
									\end{array} 
								\right].
							\end{equation}
							As in the case of bifurcations, the kinetic energy terms in the pressure conservation equations are neglected.
							In the following last section of this chapter we will describe how to determine time-step sizes to ensure stability for the numerical scheme introduced in \autoref{sec:fv} and \autoref{sec:muscl}.

							\section{CFL Condition} \label{sec:cfl}
							The CFL condition is set so that the information travelling along a characteristic curve only affects neighbouring cells. 
							Since the numerical scheme (\autoref{sec:fv},\autoref{sec:muscl}) only takes neighbouring cells into account doing otherwise would result in numerical errors stacking up.
							The $\Delta x$ from the space discretization is set according to how high a resolution the solution needs to be computed.
							Given this constraint $\Delta t$ can be determined.
							Taking into account the aforementioned condition of preventing the characteristic curves from reaching beyond the neighbouring cell within $\Delta t$ leads to the following equation
							\begin{equation}
								\Delta t \leq C_{CFL} \frac{\Delta x}{S_{max}},\hspace{10pt}  C_{CFL} \in (0,1),
							\end{equation}
							where $S_{max} = \max_{x \in [0,L], v \in V} | u_v(x) + c_v(x) |$ and $V$ is the set of all vessels in the simulation.  
							In our case $\Delta x$ was chosen to be at least $10^{-3}m$ and $C_{CFL}$ was set to $0.9$.
							In the next chapter we will go over issues that can occur and methods to be used when implementing our previously described numerical methods in JAX.

							\chapter{Implementation} \label{chap:impl}
							Since differentiability was a priority in the implementation of this model, the library JAX, which is available as a package in Python was used.
							In order to leverage the full effectiveness of JAX some special considerations had to be made when considering how to realize the simulation described in \autoref{chap:1dm} and \autoref{chap:nm}.
							In this chapter we  will give an overview of the functionality of JAX relating to this thesis in \autoref{sec:jax} and then describe the broad structure of the implemented code in \autoref{sec:cs}.


							\section{JAX} \label{sec:jax}
							JAX used to stand for "Just After eXecution" which refers to the manner in which JAX used to optimize during compilation.
							JAX achieves optimization during compilation, among other things, through tracing.
							While tracing, the code is optimized with the help of a computational graph.
							Essentially, the code is parsed without executing it, in order to detect inefficiencies in data movement and computation.
							While JAX still uses tracing to speed up code execution it is not done in a "Just After eXecution"-manner.
							Later on JAX was thought of as a recursive acronym "JAX is Autograd and XLA" in the spirit of the well known acronym GNU ("GNU is Not Unix").
							Autograd is a now deprecated Python library that can automatically differentiate native Python and NumPy code.
							XLA stands for "Accelerated Linear Algebra" and it is an open-source compiler that optimizes models from commonly used frameworks such as PyTorch, Tensor Flow, and also JAX.
							XLA optimizes these models across different hardware platforms (CPUs, GPUs, TPUs, etc.).
							Often these optimizations done by XLA are directly integrated back into the projects the original models stem from.
							XLA is also a part of JAX but while JAX used to be based on Autograd this is not the case any more and JAX achieves automatic differentiation through it's own implementation thereof.
							Therefore JAX is not considered an acronym nowadays and JAX is just considered a library that implements the features of Autograd in it's own way while including XLA optimization.
							This results in the potential for fast differentiable code as the result of using the JAX library.
							However the automatic differentiation as well as the XLA optimization can't be applied to any Python code hence there are some caveats that had to be taken into account when writing this numerical code using JAX.
							We will be addressing these caveats in the next five subsections starting with the functional purity required when programming using JAX.

							\subsection{Functional Purity}
							All JAX code has to be written in a functionally pure manner.
							This means that all inputs to a function need to be passed explicitly through the function's arguments while all outputs need to be returned explicitly through the return variables.
							Hence any kind of global variables should be avoided at all costs.
							The reason for this is that otherwise unwanted side effects might occur.
							This would mean that a global variable that has a certain value at compile time and changes it's value during code execution will in the eyes of JAX always keep the value it had assigned at compile time.
							The described behaviour might lead to unexpected results as a side effect of the compilation JAX performs.
							Furthermore this behaviour is not guaranteed leading to the only way to write code in JAX that provides fully reproducible results is to code in a fully functionally pure manner.

							\subsection{Vectorization} \label{sec:vect}
							JAX's optimization is geared towards leveraging the capabilities of GPUs.
							This means vectorization is key in making full use of JAX's optimization.
							The equations of the MUSCL solver within a single vessel are very suitable for vectorization.
							This is because the numerical scheme describes and update formula for each point that can be executed in parallel to one another.
							Vectorization can even be applied more widely using the techniques padding (\autoref{sec:pdd}) and masking (\autoref{sec:msk}) described in upcoming sections.

							\subsection{Padding} \label{sec:pdd}
							The MUSCL solver in \autoref{sec:muscl} is described for a single vessel.
							However all of the MUSCL solvers applied to the individual vessels could be performed simultaneously and even in a vectorized manner.
							In order to do so the values to be computed on by the MUSCL solver of each vessel are all written into one single array and one MUSCL solve is performed on the entire array.
							To avoid errors at the ends of a vessel, where the values stored from one vessel would influence the computed values for another vessel, one can apply padding.
							In this case this means to add entries in the array between each array that are solely there to avoid two neighbouring vessels from influencing one another.
							The errors that occur from collecting all data in one array then only effect the padded entries which are ignored when reading out the final results.
							After each MUSCL solve, when computing boundary conditions for each vessel, the padded areas are set to equal the values of the edges of the adjacent vessels.
							Finally the technique of padding doesn't just allow for efficiently applying the MUSCL solver to all vessels at once but also allows to use an inhomogeneous mesh on the vessels of the simulation.
							That means every vessel can be meshed according to it's need which is very useful in this kind of simulation since the vessel can be severely different in size.
							The reason for why padding allows for the inhomogeneous mesh is described in the next section.

							\subsection{Static Array Sizes and Avoiding Loops} \label{sec:al}
							The sizes of arrays computed on in JAX codes need to all be known at the time of tracing, i.e. JAX needs to be able to infer all array sizes at compile time in order to be able to apply it's optimizations.
							Furthermore it is recommended to avoid loops when writing code with JAX.
							This is because these loops need to be unrolled completely during JAX's compilation.
							This can be avoided by using JAX built-in loop constructions.
							However these have restrictions and one needs to satisfy a very strict signature when writing loops with these constructions.
							Specifically the arrays operated on in each iteration of the loop need to be of the same size.
							So if it were not for padding the MUSCL solver would have to be applied to each vessel separately by looping over all vessels.
							This could be done with a common Python for loop resulting in long compilation times when simulating cardiovascular systems consisting of many vessels due to having to having to fully unroll the loop.
							Another option would be to us one of the JAX loop constructions, the so-called JAX \emph{fori\_loop}.
							This would avoid the large overhead at compile time.
							However the restriction of having to have the same-sized arrays in every loop iteration would make the simulation either inherently inefficient or inherently in-accurate since very small vessels would have to simulated with fine meshes or vice versa large vessels with coarse meshes.
							Therefore padding doesn't only allow for increased vectorization but also provides the ability to use an inhomogeneous mesh while keeping the compilation time relatively short at the same time.
							In some cases loops can't be avoided by padding alone but another technique called masking has to be applied which we will describe in the next section.

							\subsection{Masking} \label{sec:msk}
							At certain points within the MUSCL solver ghost cells need to be inserted at the edges of the vessels.
							In order to avoid having to loop over the array and introducing the usual issues mentioned in the previous section that come along when using loops in JAX one can apply these values using a technique called masking.
							In order to apply the wanted value to the ghost cells one needs to store five arrays.
							Once the original array that needs to have ghost cells inserted padded with a zero on either end, two times the original array shifted forwards and backwards with two zeros at the beginning or the end respectively, and two times a boolean array containing the locations of either the ghost cells at the inlet or the outlet.
							The padded original array, the forward shifted array and the boolean array with the locations of the ghost cells at the outlets can be combined with the JAX equivalent of the NumPy where function to insert the outlet ghost cells.
							Equivalently for the original array, the shifted back array, the boolean array with the locations of the ghost cells at the inlets, and the inlet ghost cells.

							\section{Code Structure} \label{sec:cs}
							The code structure is denoted in pseudo-code in \autoref{lst:pc}.
							The whole simulation is contained in the function runSimulation that takes the arguments config\_filename and $J$, the maximum number of time steps to take before terminating a simulation if it hasn't finished yet.
							Before the simulation is run the simulation data needs to be initialized.
							This is done through hard coded functions that set initial values such as described in \autoref{ssec:initial_conditions} and from values read from the file \emph{<path/to/network\_configuration>.yml}.
							The steps to initialize our network are denoted on lines \ref{ln:init_start} through \ref{ln:init_end} in the pseudo-code.
							Specifically we set initial data ($u(z;0)$, $A(z;0)$, $Q(z;0)$, \autoref{ssec:initial_conditions}) for each vessel, inlet data ($P(0;t)$ or $Q(0;t)$, \autoref{sssec:inlets}) at all inlets, outlet parameters ($R_t$, $R_1$, $C$, $R_2$, \autoref{sssec:outl}) for outlet vessels, mesh sizes ($\Delta x$, \autoref{sec:fv}) and parameters ($\beta$, $P_{ext}$, \autoref{sec:sv}) for each vessel, and global parameters ($\rho$, $T$, $C_{CFL}$, $N$, \autoref{sec:b},\autoref{sec:cfl}, where $N$ stands for the number of vessels in the network).
							Then we generate the $J \times N$ matrix P\_t that will be used to store the pressure values at the centre of each vessel throughout one cardiac cycle.
							Thereafter a while loop is initiated in lines \ref{ln:whout1} and \ref{ln:whout2} within which at each iteration an entire cardiac cycle of length $T$ is computed.
							In this while loop we first set the time $t$ at which we want to simulate the system and a counter of time steps taken in the current cardiac cycle to $0$ in lines \ref{ln:t0}-\ref{ln:i0} and then we store a copy of the pressure data (line \ref{ln:cp}) so we can compare the two after storing the results from the upcoming solver in the new copy.

							Each cardiac cycle is itself described by a while-loop that computes the next time step (line \ref{ln:cfl}) using the $C_{CFL}$ parameter as in \autoref{sec:cfl}, updates boundary values (line \ref{ln:bv}) as in \autoref{ssec:boundary_values} by using either a reflective model with the parameter $R_t$ or a Windkessel model using the parameters $R_1$, $C$, $R_2$, executes the MUSCL solver described in \autoref{sec:muscl} over all vessels (line \ref{ln:muscl}) advancing $\mathbf{U}_i^{n}$ to $\mathbf{U}_i^{n+1}$ $\forall i \in \{1,...,M\}$, saves the pressure at the centre of each vessel for each individual time-step (line \ref{ln:svp}), and finally increases the time by the time-step that was just computed (line \ref{ln:updt}) and the time-step counter by $1$ (line \ref{ln:updi}).
							This while loop also contains a condition that will exit the loop if more than $J$ time-steps have been computed for the current cardiac cycle.
							After computing a cardiac cycle, the saved pressures are compared to the ones from the previous cardiac cycle at each vessel in line \ref{ln:conv}.
							Cardiac cycles are computed until the pressure differences in each vessel are smaller than $0.1$ mmHg in the euclidean norm which is expressed by line \ref{ln:conv}.
							This is in accordance with the comment made in \autoref{ssec:initial_conditions} about a steady state needing to be reached in order to get rid of negative effects from imprecisely set initial conditions.
\begin{lstlisting}[language=Python, caption=The code structure of an entire simulation is given here in pseudocode. Each line is detailed throughout this section., label=lst:pc, escapechar=|]
def runSimulation(config_filename, J)
	config = loadConfig(config_filename) |\label{ln:init_start}|
	simulation_data = buildArterialNetwork(config) |\label{ln:init_end}|

	P_t = [0] |\label{ln:pt}|

	converged = False |\label{ln:whout1}|
	while not converged: |\label{ln:whout2}|
		t = 0 |\label{ln:t0}|
		i = 0 |\label{ln:i0}|
		P_t_temp = P_t |\label{ln:cp}|
		while t < T:
			dt = computeDt(simulation_data) |\label{ln:cfl}|
			simulation_data = setBoundaryValues(simulation_data, dt) |\label{ln:bv}|
			simulation_data = muscl(simulation_data, dt) |\label{ln:muscl}|
			P_t[i,:] = savePressure(simulation_data) |\label{ln:svp}|
			t = t + dt |\label{ln:updt}|
		i = i + 1 |\label{ln:updi}|
		if i >= J
			break
		converged = checkConv(P_t, P_t_temp) |\label{ln:conv}|
						\end{lstlisting}
						It is noted that the computation of the boundary conditions in line \ref{ln:bv} requires a for loop.
						This for loop is constructed using the JAX \emph{fori\_loop} as discussed in \autoref{sec:al} in order to the improve scaling of the compile time.
						The same goes for the two while loops mentioned in \autoref{lst:pc} and their JAX equivalent \emph{while\_loop}.
						The effect of avoiding built-in Python loops can be seen in \autoref{sec:sc}.
						On the other hand the need for loops has been completely avoided when executing the MUSCL solver on all vessels (line \ref{ln:muscl}).
						This was done by applying padding (\autoref{sec:pdd}) and masking (\autoref{sec:msk}) allowing for JAX to better optimize this code section and leverage GPU resources more effectively as opposed to an implementation using loops.
						Finally what is denoted in \autoref{lst:pc} by \emph{simulation\_data} consists of multiple 2D-arrays containing global constants, vessel constants, and simulation quantities.
						While this is less accessible to read than for instance having a class that describes a vessel it allows for more efficient data movement and to more easily adhere to JAX's requirements when using their loop constructs or their optimizations overall.
						Details on how to run the model we described here, as well as instructions on how to parse model configurations from different sources and perform parameter inference, can be found in \autoref{app:doc}. 
						In the next chapter we will go over the results we got from running our code.



						\chapter{Results} \label{chap:resl}
						In this chapter we will present the results produced with our JAX implementation of the haemodynamics solver described in \autoref{chap:1dm} and \autoref{chap:nm}. 
						Firstly we will validate the code against previous work in \autoref{sec:val} and compare the time taken to compute models between our implementation and the implementation used for validation.
						Then, in \autoref{sec:da} we will show some examples of simulations that were run on different anatomies using our implementation.
						In \autoref{sec:sc} we will talk about scaling with respect to the compile time and run time of our code.
						Finally in \autoref{sec:pi} we describe an example of the code performing parameter inference. 

					\section{Validation and Comparison} \label{sec:val}
						In order to validate our code we compared it to the 1D-haemodynamics solver openBF \cite{openBF} that was written and validated during the course of the thesis \cite{melis2017gaussian}.
						That code was written in the julia programming language \cite{julia}.
						We chose four models that will be introduced more closely in \autoref{sec:da}.
						We present from each model a randomly selected vessel and compare the pressure wave over one cardiac cycle in the middle of said vessel.
						The four models consist of 9, 17, 19, and 77 vessel segments each.
						That means 9, 17, 19, and 77 segments that each get treated as an individual vessel on which the 1D-NSE have to be solved (\autoref{sec:sv}) and that have to be coupled to one another by solving the connecting junctions (\autoref{sssec:junctions}).
						The result of comparing the codes can be seen in \autoref{fig:val} where the \emph{P\_JAX} refers to the pressure computed by our code throughout one cardiac cycle and \emph{P\_jl} refers to the equivalent values from the openBF code.
						\begin{figure} [H]
							\centering
							\includegraphics[width=0.4\columnwidth]{figures/0007_H_AO_H_right_subclavian_artery_P.eps}
							\includegraphics[width=0.4\columnwidth]{figures/0029_H_ABAO_H_celiac_branch_P.eps
							}
							\includegraphics[width=0.4\columnwidth]{figures/0053_H_CERE_H_basilar_artery_IV_P.eps}
							\includegraphics[width=0.4\columnwidth]{figures/adan56_common_hepatic_P.eps}
							\caption{Our code and the openBF code produce close to the same output. In the 0007\_H\_AO\_H and the 0029\_H\_ABAO\_H networks this even leads to the plot of the data from our code being almost completely obfuscated by the openBF data.}
							\label{fig:val}
\end{figure}
The plots show that for each model there is barely any difference in the output of the two vascular simulations.
Furthermore there is a less than $1\%$ relative error between openBF's and our implementation which validates our codes correctness.
We also compared the time each of the simulators took to run model with varying numbers of vessel segments.
For this the models were run 10 times each and the computation time was calculated by taking the average of these 10 measurements.
The results can be seen in \autoref{fig:comparison}.
\begin{figure} [H]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/comparison.eps}
	\caption{Smaller systems suffer from the overhead JAX compilation creates but for larger models the execution times become equal. For the largest model the JAX code even beats the julia implementation.}
	\label{fig:comparison}
\end{figure}
As is to be expected for smaller models the JAX code performs worse than the julia code do to the overhead of the JAX compilation not paying of.
However it can be seen that the optimizations start to pay of as the simulated network size increases, where the JAX code finally is faster then the julia implementation at $77$ vessel segments.
These comparisons were produced on a Xeon E3-1505 v6 with 4 cores and 8 threads, a base frequency of 3.0GHz and a maximum turbo frequency of 4.0GHz, 8MB of cache, and 16GB of DDR4 memory clocked at 2400MT.
In the next section we will discuss the results computed by our JAX implementation of the 1D-haemodynamics solver.

\section{Different Anatomies} \label{sec:da}
We present here the pressure waves simulated by our code on four different models.
All models represent anatomies from healthy individuals.
The vessel wall thickness was computed using the empirical expression
\begin{equation}
	h_0 = r_0 \left(a \exp(b r_0) + c \exp(d r_0)\right),
\end{equation}
taken from \cite{blanco2014anatomically} with the parameters
\begin{equation}
	a = 0.2802, \ b = -5.053 \text{cm}^{-1}, \ c = 0.1324,\  d = -0.1114 \text{cm}^{-1}.
\end{equation}
Three of the models are taken from the \emph{vascularmodel.com} website \cite{vascularmodel}.
These three models represent arteries around the aorta, abdominal arteries and arteries of the cerebral circulation.
The input data provided by \emph{vascularmodel.com} was used to set the inlet boundary conditions.
The Young's modulus for these models was calculated using the parametrization:
\begin{equation}
	E = \frac{r_0}{h} k_1 \exp(k_2 r_0) + k_3,
\end{equation}
given in \cite{ottesen2004applied} with the values
\begin{align}
	k_1 &= 2.00 \times 10^7 \frac{\text{g}}{\text{s}^2\text{cm}}, \\
	k_2 &= -22.53 \frac{1}{\ \text{cm}}, \\
	k_3 &= 8.65 \times 10^5 \frac{\text{g}}{\text{s}^2\text{cm}}.
\end{align}
The fourth model is the so-called "anatomically-detailed arterial network" or "ADAN" model and it is made up of the largest arteries of the human circulation.
The model was developed by Blanco et al. \cite{blanco2014anatomically,blanco2014blood} and this specific variant of it contains 56 vessels.
Therefore it is commonly referred to as "ADAN56".
The 56 vessels are split into 61 arterial segments which are in turn split into a total of 77 segments for simulation purposes.

The results from the first model from \emph{vascularmodel.com}, the aorta model, can be seen in \autoref{fig:aorta}.
The model represents the ascending, the descending and the arch of the aorta as well as the brachiocephalic and the right and left subclavian and common carotid arteries.
These arteries are listed in \autoref{tab:aort} which also serves as a legend for the corresponding figure.
\begin{figure} [H]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/0007.eps}
	\caption{The haemodynamics solver produces qualitatively accurate results for the 8 vessel aorta model.}
	\label{fig:aorta}
\end{figure}
\begin{table}[H] 
	\begin{center}
		\begin{tabular}{|c|l|c|l|} 
			\hline
			Legend & Vessel Name &Legend & Vessel Name\\
			\hline
			$\mathbf{1}$& ascending aorta &
			$\mathbf{5}$& arch of aorta \\
			$\mathbf{2}$& brachiocephalic artery &
			$\mathbf{6}$& left common carotid artery \\
			$\mathbf{3}$& right subclavian artery &
			$\mathbf{7}$& descending aorta \\
			$\mathbf{4}$& right common carotid artery &
			$\mathbf{8}$& left subclavian artery \\
			\hline
		\end{tabular}
	\end{center}
	\caption{This table lists the 8 arteries of the aorta model displayed in \autoref{fig:aorta}.}
	\label{tab:aort}
\end{table}

The second \emph{vascularmodel.com} model, the abdominal model, consists among others of the following arteries: 
The right and left common and internal iliac arteries, as well as the right and left renal arteries, the celiac trunk and the superior mesentric artery.
The results from our simulation of the abdominal model can be seen in \autoref{fig:abdominal} and the corresponding legend is contained in \autoref{tab:abdo}.
\begin{figure} [H]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/0029.eps}
	\caption{The abdominal model consists of 10 vessels and is therefore slightly larger than the aorta model but still produces physiologically realistic values.}
	\label{fig:abdominal}
\end{figure}
\begin{table}[H]
	\begin{center}
		\begin{tabular}{|c|l|}
			\hline
			Legend & Vessel Name\\
			\hline
			$\mathbf{1}$& aorta \\ 
			$\mathbf{2}$& celiac trunk \\
			$\mathbf{3}$& celiac branch \\
			$\mathbf{4}$& superior mesentric artery \\
			$\mathbf{5}$& left renal artery \\
			$\mathbf{6}$& right renal artery \\
			$\mathbf{7}$& left common iliac artery \\
			$\mathbf{8}$& left internal iliac artery \\
			$\mathbf{9}$& right common iliac artery \\
			$\mathbf{10}$& right internal iliac artery \\
			\hline
		\end{tabular}
	\end{center}
	\caption{This table lists the 10 arteries of the abdominal model displayed in \autoref{fig:abdominal}.}
	\label{tab:abdo}
\end{table}

Our final model from the \emph{vascularmodel.com} database models cerebral arteries.
It includes among others the right and left anterior inferior cerebellar arteries the right and left vertebral arteries.
The results from simulating the cerebral model are shown in \autoref{fig:cerebral}.
The corresponding table containing the vessel names and their label is \autoref{tab:cere}
\begin{figure} [H]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/0053.eps}
	\caption{The 10 vessel cerebral model provides reasonable results as well when simulated with our haemodynamics solver.}
	\label{fig:cerebral}
\end{figure}
\begin{table}[H]
	\begin{center}
	\begin{tabular}{|c|l|}
			\hline
			Legend & Vessel Name\\
			\hline
			$\mathbf{1}$& right vertebral artery \\ 
			$\mathbf{2}$& right posterior meningeal branch of vertebral artery \\
			$\mathbf{3}$& left posterior meningeal branch of vertebral artery\\
			$\mathbf{4}$& left vertebral artery \\ 
			$\mathbf{5}$& right anterior inferior cerebellar artery \\
			$\mathbf{6}$& left anterior inferior cerebellar artery \\
			$\mathbf{7}$& basilar artery \\
			$\mathbf{8}$& right superior cerebellar artery \\
			$\mathbf{9}$& left superior cerebellar artery \\
			$\mathbf{10}$& right posterior central artery \\
			$\mathbf{11}$& right posterior cerebellar artery \\
			$\mathbf{12}$& right posterior communicating artery \\
			\hline
		\end{tabular}
	\end{center}
	\caption{This table lists the arteries displayed in \autoref{fig:cerebral}.}

	\label{tab:cere}
\end{table}

Finally we turn to the "ADAN56" model.
With 56 vessels this is by far the biggest model presented here.
The input data here was inspired by \cite{murgo1980aortic}.
The results are visualized in \autoref{fig:adan56}.
\begin{figure} [!ht]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/adan56.eps}
	\caption{The simulation results from the ADAN56 artery network show that larger systems can be simulated by our JAX code as well. This diagram was taken from \cite{boil2015}.}
	\label{fig:adan56}
\end{figure}
A stark difference between the models from \emph{vascularmodel.com} and the ADAN56 model is how much variety there is in the different pulse waves generated for different arteries in the ADAN56 model as opposed to the ones generated for the other models.
This is most likely a result of the way the Windkessel or RCR parameters were set for these different models.
For the ADAN56 model the resistances and the compliance were carefully analysed and calibrated in \cite{blanco2014anatomically,blanco2014blood} to provide a physiologically realistic result.
Due to the parameters not always being provided in the \emph{vascularmodel.com} models, here they were computed using a fairly simple approximation.
The total resistance of the system is computed as:
\begin{equation}
	R_{tot} := \frac{P_{mean}}{Q_{car}},
\end{equation}
where the mean pressure $P_{mean}$ and the cardiac output $Q_{car}$ are set to the nominal values:
\begin{align}
	P_{mean} &:= \frac{120 \text{mmHg}}{80 \frac{\text{ml}}{\text{s}}} \approx 2 \times 10^8 \frac{\text{kg}}{\text{m}^4\text{s}}, \\
	Q_{car} &:= 80 \frac{\text{ml}}{\text{s}} = 8 \times 10^{-5} \frac{\text{m}^3}{\text{s}}. \\
\end{align}
The total compliance is set to a reasonable value as well
\begin{align}
	C_{tot} &:= 10^{-3} \frac{\text{cm}^5}{\text{dyne}} = 10^{-8} \frac{\text{m}^3}{\text{Pa}}.
\end{align}
The individual resistances and the compliances are then set using the rules for a parallel circuit.
Let $I$ be an index set containing all vessels with a Windkessel outlet and $A_{o,i}, i \in I$ the reference cross-section at the outlet of the $i$-th vessel.
The resistance and the compliance at vessel $i$ are then computed by
\begin{align}
	\xi_i &:= \frac{\sum_{j \in I} A_{0,j}}{A_{0,i}}, \\
	R_{tot,i} &:= \xi_i R_{tot}, \\
	C_{tot,i} &:= \frac{1}{\xi_i} C_{tot}. 
\end{align}
Finally the proximal and the distal resistance $R_{1,i}, R_{2,i}$ have to be set for each vessel $i$.
This is done by invoking an approximate ratio of about 1:10 between the two
\begin{align}
	R_{1,i} &:= \frac{9}{100} R_{tot,i}, \\
	R_{2,i} &:= \frac{91}{100} R_{tot,i}.
\end{align}
This recipe was taken from the \emph{simvascular} documentation. \cite{simvascular}
Some of the resistances were manually fitted to better suit the specific models.
The different behaviours in the simulation for the meticulously assigned parameters in the ADAN56 model as opposed to the approximated parameters assigned when simulating the \emph{vascularmodel.com} models demonstrate that there is no simple answer to calibrating the RCR parameters for the Windkessel model.
This is supported by a closer description of techniques and issues when it comes to calibrating the RCR parameters given in \cite{köppl2023dimension}.
Here the code written in this work can be seen as a step towards easier and more accurate procedures to determine such parameters.
Given data the differentiability of the code could be leveraged to perform parameter inference on precisely these parameters.

\section{Scaling} \label{sec:sc}
As mentioned in \autoref{sec:jax} on JAX there is a significant overhead to the compilation JAX performs in order to optimize.
This begs the question if the compilation dominates the computation time and how the compilation time scales for growing numbers of vessel segments in a simulated network.
Here computation time includes the duration of the compilation and the simulation of a model while the compilation time only describes the time JAX needs to compile before the actual simulation.
If the compilation time doesn't increase much even for larger models this would mean that for big enough systems the compilation overhead could pay off.
The compilation and computation time have been plotted for simulations with different numbers of vessel segments in \autoref{fig:timing}.
These timings were produced on the same setup as described in \autoref{sec:val}.
\begin{figure} [!ht]
	\centering
	\includegraphics[width=0.8\columnwidth]{figures/timing.eps}
	\caption{The compile time doesn't grow significantly with increasing numbers of vessel segments due to built-in Python loops being avoided which would be costly to compile due to the loops having to be unrolled. Total compute times seem to scale linearly w.r.t. he number of vessel segments with the exception of the 19 vessel segment simulation.}
	\label{fig:timing}
\end{figure}
The compile time remains almost constant around 3 seconds even as the number of vessel segments increases about $80$ times.
This is due to the methods applied that were described in \autoref{sec:al}.
Specifically due to avoiding built-in python loops in favour of JAX loop constructions the compile time is kept more or less static since these kind of loops do not have to be unrolled during compilation.
Hence there is barely any additional effort involved with compiling for larger network simulations.
In general the compile time is only a fraction of the compute time once a certain amount of vessels is considered in the simulation and it becomes insignificant with growing model sizes.
It can also be observed that the compute times shows linear scaling as a function of the number of vessel segments when considering the 19 vessel segment data point to be an outlier.
Convergence within a simulation is heavily dependent on the specific network that is being simulated.
Therefore it is reasonable to assume that there will be outliers when comparing the compute times between simulations with different underlying networks.

It is important to notice that these timings were computed on a CPU since the performance of our implementation is better on CPUs as opposed to GPUs.
This could maybe be improved by farther optimizing the code but most likely also stems at least partially from the fact that a 1D-model as we use it does not lend itself well to efficient GPU execution.
This is due to the operations being performed not being able to leverage the massive parallelism a GPU offers since the spatial mesh used for the numeric approximation is not very big and the time steps have to be solved sequentially.
However for larger models than the ones presented here and running multiple models in parallel it might still be advantageous to run on a GPU.
%A possible improvement we might suggest however is to avoid solving the junctions by solving many small linear systems of equations and instead solving one large sparse system.
In the upcoming final section of this chapter we will present a parameter inference on a toy problem.


\section{Parameter Inference} \label{sec:pi}
In order to demonstrate the ability of our code to perform a parameter inference we present here a toy problem.
For this toy problem we try to infer a parameter of a system consisting of a single bifurcation as described in \autoref{sssec:junctions}.
Here we tried to infer one of the $R_1$ parameters of the Windkessel models (\autoref{sssec:outl}) at the two outlets of the three vessel system.
In order to perform the inference, the No-U-Turn Sampler (NUTS) \cite{hoffman2014no} was used to perform a Hamiltonian Monte Carlo \cite{duane1987hybrid} optimization with adaptively set path lengths.
Before being able to do the optimization we simulated a baseline using the solver introduced during the course of this thesis with a reasonable value for the Windkessel parameter to be inferred.
We set the parameter to $\hat{R}_1=6.8123 \times 10^7$.
The output of this simulation will be used as the target of the optimization algorithm.
 
Once our baseline was computed we initialized a prior $\bar{R}_1 \sim 10^8 \times \mathcal{N}(0,1)$ around an offset value of our original Windkessel parameter $\hat{R}_1$.
Our observed data from the baseline computation and the prior we just defined were provided in a model to the \emph{NumPyro} \cite{phan2019composable,bingham2019pyro} implementation of the Markov-Chain-Monte-Carlo method using the NUTS sampler.
The optimizer was run with 10 warm-up-steps and 200 sample-steps.
The parameter inference took roughly one hour and returned $7 \times 10^7$ as the mean for the posterior of $\bar{R}_1$ leading to a relative error of about $2.5\%$.

While this is a very small system and the time taken to perform the inference is quite high we present this example as proof that our code is differentiable and that parameter inference can be performed by applying this differentiability.
For more efficient and broader inferences extensive tuning and further optimization might be necessary. We refer the interested reader to \autoref{app:doc} in order to run the toy problem described here.
In the upcoming final chapter we will summarize our results produced in this thesis and give an outlook upon future work that this contribution might be a precursor to.

\chapter{Conclusion/ Future Work} \label{chap:conc}
To conclude this work we state the goal that this thesis set out to accomplish, the methods applied and the results thereof.
Finally we will give an outlook on future work that is enabled do to our contribution.
The goal of this thesis was to write a differentiable 1D-haemodynamics solver.
The underlying motivation thereof being the need for cardiovascular simulations in medicine, specifically in personalised medicine.
The aim of having the solver be differentiable is to enable efficient parameter inference and sensitivity analysis.

The construction of a differentiable solver was successful and was achieved using well established methods such as the reduction of the 3D-NSE to their 1D-equivalent in \autoref{sec:sv} and the solving of these equations using the MUSCL numerical method in \autoref{sec:muscl}.
The differentiability specifically results from the implementation in JAX.
We could demonstrate that our code reproduces the results from previous work and does so while the execution time scales linearly w.r.t. the number of vessels and the compilation time is near constant over different network constellations (\autoref{sec:val}, \autoref{sec:sc}).
Furthermore we showed that our solver can produce physiologically realistic results on models that were produced from 3D-geometries \autoref{sec:da}.
Regarding parameter inference we could demonstrate it's feasibility on a toy problem.

While the main goal of making a differentiable 1D-haemodynamics solver was achieved there are still issues that need to be addressed.
First off there may be potential to improve execution times on GPUs, especially the solving of junctions. 
This consists of solving many small linear systems which is not a workload that offers itself readily to GPU optimization.
Reformulating this part of the solver, perhaps in the form of one large sparse system may lend itself better to execution on the GPU.
Despite this being an inefficient way of solving the problem when computing naively, on a GPU and combined with the optimizations from JAX this might lead to better performance.
It is also possible that the advantages of computing on a GPU could only be leveraged for very large systems or when running many simulations simultaneously.
This would have to be explored more closely.

Furthermore we provided a differentiable solver which enables more efficient parameter inference however to apply this successfully to personalised medicine requires a lot of testing and tuning of the parameter inference process and would be aided heavily by a sensitivity analysis.
Extensive parameter inference and sensitivity analysis hasn't been included in this work due to time constraints but the provided model would lend itself readily to such tasks.
We consider the parameters of the Windkessel model to be a favourable target for such future work since they depend heavily on many physiological factor and there is no straightforward method of determining them for a given vascular network.

The computing of parameters for an individual is one task where the differentiability of our code could be leveraged.
Another way of applying the solver we have produced would be to learn laws governing the behaviour of our vascular simulator.
This is especially useful when considering laws that are not well understood and that are based off of an empirical understanding of the underlying phenomenon.
This leads to there being no conclusive correct way to model something within the simulator.
A prime example for this is the tube law, here described by \autoref{eq:p_tot}.
While there is a lot of literature suggesting and comparing different methods of computing the tube law there is no method that is considered to be the best or even fundamentally correct \cite{gomez2017analysis}.
It would therefore be interesting to use data to infer this law and compare the results to the values obtained by using one of the given models from the literature.

In general we believe this work offers fruitful ground for future contributions, be it through producing an even faster and more GPU friendly differentiable solver or using the existing solver to learn parameters and underlying laws of 1D-haemodynamic solvers.



% This displays the bibliography for all cited external documents. All references have to be defined in the file references.bib and can then be cited from within this document.
\bibliographystyle{IEEEtran}
\bibliography{references/references}

% This creates an appendix chapter, comment if not needed.
\appendix
\chapter{Code Documentation/ Manual} \label{app:doc}
The code written for this thesis can be found at \cite{jaxflowsim}.
It offers the ability to parse models, run models, and infer parameters.
The parsing scripts can be found in the \emph{parsing} folder.
Models can be parsed from two different formats.
The first format being models provided by \cite{vascularmodel}.
In order to parse these kinds of models the files representing a 3D-model from \emph{vascularmodel.com} needs to be placed in the parsing folder.
Furthermore an encoding of the network structure done by centre-line extraction needs to be placed in the model folder as well.
This network structure can be generated using the \emph{Slicer 3D} software \cite{fedorov20123d}.
In order to parse a \emph{vascularmodel} network, once the files have been placed appropriately, run

\texttt{python parse\_vm.py <model\_name>}.

The second format that can be parsed is the format used in the openBF-hub repository \cite{openbfhub}.
In order to parse these models the repository need to be cloned in to the \emph{parsing} folder.
Then the models can be parsed by running

\texttt{python parse\_bf.py <model\_name> <model\_sub\_dir>}

where depending on the model the \emph{model\_sub\_dir} argument might not be relevant. 
The parsed models are all stored in the \emph{test} folder.
They can be run by executing the following command in the base directory of the \emph{jaxFlowSim} repository

\texttt{python run\_model.py <model\_name>}.

The results of a successfully simulated model can be found in the folder \emph{results/<model\_name>}.
Finally a parameter inference can be run by executing

\texttt{python run\_inference.py <model\_name>}.

in the base directory as well.
We note that the inferring of a parameter in this manner is very experimental and requires that the user hand tunes the file \emph{src/inference.py}.
However by running 

\texttt{python run\_inference.py}.

without an argument the toy problem from \autoref{sec:pi} can be computed.






\end{document}

